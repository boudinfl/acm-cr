@article{10.1145/971697.602261,
author = {DeWitt, David J and Katz, Randy H and Olken, Frank and Shapiro, Leonard D and Stonebraker, Michael R and Wood, David A.},
title = {Implementation Techniques for Main Memory Database Systems},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602261},
doi = {10.1145/971697.602261},
abstract = {With the availability of very large, relatively inexpensive main memories, it is becoming possible keep large databases resident in main memory In this paper we consider the changes necessary to permit a relational database system to take advantage of large amounts of main memory We evaluate AVL vs B+-tree access methods for main memory databases, hash-based query processing strategies vs sort-merge, and study recovery issues when most or all of the database fits in main memory As expected, B+-trees are the preferred storage mechanism unless more than 80--90% of the database fits in main memory A somewhat surprising result is that hash based query processing strategies are advantageous for large memory situations},
journal = {SIGMOD Rec.},
month = jun,
pages = {1–8},
numpages = {8},
keywords = {recovery mechanisms, main memory databases, join algorithms, access planning, access methods}
}

@inproceedings{10.1145/602259.602261,
author = {DeWitt, David J and Katz, Randy H and Olken, Frank and Shapiro, Leonard D and Stonebraker, Michael R and Wood, David A.},
title = {Implementation Techniques for Main Memory Database Systems},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602261},
doi = {10.1145/602259.602261},
abstract = {With the availability of very large, relatively inexpensive main memories, it is becoming possible keep large databases resident in main memory In this paper we consider the changes necessary to permit a relational database system to take advantage of large amounts of main memory We evaluate AVL vs B+-tree access methods for main memory databases, hash-based query processing strategies vs sort-merge, and study recovery issues when most or all of the database fits in main memory As expected, B+-trees are the preferred storage mechanism unless more than 80--90% of the database fits in main memory A somewhat surprising result is that hash based query processing strategies are advantageous for large memory situations},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {1–8},
numpages = {8},
keywords = {recovery mechanisms, join algorithms, access methods, access planning, main memory databases},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602262,
author = {Simon, Eric and Valduriez, Patrick},
title = {Design and Implementation of an Extendible Integrity Subsystem},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602262},
doi = {10.1145/971697.602262},
abstract = {Tnls paper presents a powerful integrrty subsystem, which is implemented in the SABRE database system. The specification language is simple. Tne enforcement algorithm is general, in particular, it handles referential dependency and temporal assertions. Specialized strategies efficiently treat each class of assertions. The system automatically manages integrity checkpoints. Also, an efficient method is described for processing assertions involving aggregates. An analysis exhibits the value of the algorithms. It 1s shown that, in general, this method is better than the query modification method for domain assertions. Measures have also been done for giving the cost added for controlling integrity in comparison with the cost of the request itself.},
journal = {SIGMOD Rec.},
month = jun,
pages = {9–17},
numpages = {9}
}

@inproceedings{10.1145/602259.602262,
author = {Simon, Eric and Valduriez, Patrick},
title = {Design and Implementation of an Extendible Integrity Subsystem},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602262},
doi = {10.1145/602259.602262},
abstract = {Tnls paper presents a powerful integrrty subsystem, which is implemented in the SABRE database system. The specification language is simple. Tne enforcement algorithm is general, in particular, it handles referential dependency and temporal assertions. Specialized strategies efficiently treat each class of assertions. The system automatically manages integrity checkpoints. Also, an efficient method is described for processing assertions involving aggregates. An analysis exhibits the value of the algorithms. It 1s shown that, in general, this method is better than the query modification method for domain assertions. Measures have also been done for giving the cost added for controlling integrity in comparison with the cost of the request itself.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {9–17},
numpages = {9},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602263,
author = {Boral, Haran and Gold, Israel},
title = {Towards a Self-Adapting Centralized Concurrency Control Algorithm},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602263},
doi = {10.1145/971697.602263},
abstract = {We introduce the notion of self-adapting concurrency control algorithms --- concurrency control algorithms that consist of several rw and several ww synchronization techniques, and employ combinations of the techniques in a manner that attains a performance objective. We Consider synchronization techniques that use locking and certification. A general proof method for such algorithms is outlined and applied.},
journal = {SIGMOD Rec.},
month = jun,
pages = {18–31},
numpages = {14}
}

@inproceedings{10.1145/602259.602263,
author = {Boral, Haran and Gold, Israel},
title = {Towards a Self-Adapting Centralized Concurrency Control Algorithm},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602263},
doi = {10.1145/602259.602263},
abstract = {We introduce the notion of self-adapting concurrency control algorithms --- concurrency control algorithms that consist of several rw and several ww synchronization techniques, and employ combinations of the techniques in a manner that attains a performance objective. We Consider synchronization techniques that use locking and certification. A general proof method for such algorithms is outlined and applied.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {18–31},
numpages = {14},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602265,
author = {Arnow, David M. and Tenenbaum, Aaron M.},
title = {An Empirical Comparison of B-Trees, Compact B-Trees and Multiway Trees},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602265},
doi = {10.1145/971697.602265},
abstract = {It is well-known that the B-tree data structure yields excellent worst-case search costs and for that reason is widely employed in the organization of external files and in the implementation of data bases. In this paper, we examine general B-trees empirically and compare them with a less restrictive structure, the general multiway tree, and a more restrictive structure, the compact B-tree. We compare search costs, insertion costs, and space costs of these three structures for both small and large orders and indicate their relative utility for large and small data sets. Although there are cases when general multiway trees are more effective than B-trees, this is not the case for most practical situations. Compact B-trees are also shown to degrade rapidly in the presence of insertions and are therefore only useful for static data sets.},
journal = {SIGMOD Rec.},
month = jun,
pages = {33–46},
numpages = {14}
}

@inproceedings{10.1145/602259.602265,
author = {Arnow, David M. and Tenenbaum, Aaron M.},
title = {An Empirical Comparison of B-Trees, Compact B-Trees and Multiway Trees},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602265},
doi = {10.1145/602259.602265},
abstract = {It is well-known that the B-tree data structure yields excellent worst-case search costs and for that reason is widely employed in the organization of external files and in the implementation of data bases. In this paper, we examine general B-trees empirically and compare them with a less restrictive structure, the general multiway tree, and a more restrictive structure, the compact B-tree. We compare search costs, insertion costs, and space costs of these three structures for both small and large orders and indicate their relative utility for large and small data sets. Although there are cases when general multiway trees are more effective than B-trees, this is not the case for most practical situations. Compact B-trees are also shown to degrade rapidly in the presence of insertions and are therefore only useful for static data sets.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {33–46},
numpages = {14},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602266,
author = {Guttman, Antonin},
title = {R-Trees: A Dynamic Index Structure for Spatial Searching},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602266},
doi = {10.1145/971697.602266},
abstract = {In order to handle spatial data efficiently, as required in computer aided design and geo-data applications, a database system needs an index mechanism that will help it retrieve data items quickly according to their spatial locations However, traditional indexing methods are not well suited to data objects of non-zero size located m multi-dimensional spaces In this paper we describe a dynamic index structure called an R-tree which meets this need, and give algorithms for searching and updating it. We present the results of a series of tests which indicate that the structure performs well, and conclude that it is useful for current database systems in spatial applications},
journal = {SIGMOD Rec.},
month = jun,
pages = {47–57},
numpages = {11}
}

@inproceedings{10.1145/602259.602266,
author = {Guttman, Antonin},
title = {R-Trees: A Dynamic Index Structure for Spatial Searching},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602266},
doi = {10.1145/602259.602266},
abstract = {In order to handle spatial data efficiently, as required in computer aided design and geo-data applications, a database system needs an index mechanism that will help it retrieve data items quickly according to their spatial locations However, traditional indexing methods are not well suited to data objects of non-zero size located m multi-dimensional spaces In this paper we describe a dynamic index structure called an R-tree which meets this need, and give algorithms for searching and updating it. We present the results of a series of tests which indicate that the structure performs well, and conclude that it is useful for current database systems in spatial applications},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {47–57},
numpages = {11},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602267,
author = {Diel, Hans and Kreissig, Gerald and Lenz, Norbert and Scheible, Michael and Schoener, Bernd},
title = {Data Management Facilities of an Operating System Kernel},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602267},
doi = {10.1145/971697.602267},
abstract = {The paper describes the part of a general operating system Kernel supporting data management functions The operating system Kernel can be imbedded into microcode and viewed as an extended hardware interfaceFour Kernel instructions are defined to support data management They provide a powerful basis for the implementation of different kinds of access methods and file systems, including data base systems Advanced transaction processing concepts such as concurrency control, support of backout, commit and a variety of share options are included.},
journal = {SIGMOD Rec.},
month = jun,
pages = {58–69},
numpages = {12}
}

@inproceedings{10.1145/602259.602267,
author = {Diel, Hans and Kreissig, Gerald and Lenz, Norbert and Scheible, Michael and Schoener, Bernd},
title = {Data Management Facilities of an Operating System Kernel},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602267},
doi = {10.1145/602259.602267},
abstract = {The paper describes the part of a general operating system Kernel supporting data management functions The operating system Kernel can be imbedded into microcode and viewed as an extended hardware interfaceFour Kernel instructions are defined to support data management They provide a powerful basis for the implementation of different kinds of access methods and file systems, including data base systems Advanced transaction processing concepts such as concurrency control, support of backout, commit and a variety of share options are included.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {58–69},
numpages = {12},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602269,
author = {Fedorowicz, Jane},
title = {Database Evaluation Using Multiple Regression Techniques},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602269},
doi = {10.1145/971697.602269},
abstract = {A model of the inverted file of an automated bibliographic system is constructed using the Zipf distribution of word frequency. By ascertaining the parameters of the Zipfian model of the inverted file system, one can estimate the minimum data storage requirements of the database. In addition, given a few additional system parameters, access time for a specified query can be estimated. The estimation procedures are accomplished using logarithmic transformations and multiple regression techniques. This paper introduces the Zipfian models, their regression formulation, and their results and interpretation for application to database evaluation.},
journal = {SIGMOD Rec.},
month = jun,
pages = {70–76},
numpages = {7}
}

@inproceedings{10.1145/602259.602269,
author = {Fedorowicz, Jane},
title = {Database Evaluation Using Multiple Regression Techniques},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602269},
doi = {10.1145/602259.602269},
abstract = {A model of the inverted file of an automated bibliographic system is constructed using the Zipf distribution of word frequency. By ascertaining the parameters of the Zipfian model of the inverted file system, one can estimate the minimum data storage requirements of the database. In addition, given a few additional system parameters, access time for a specified query can be estimated. The estimation procedures are accomplished using logarithmic transformations and multiple regression techniques. This paper introduces the Zipfian models, their regression formulation, and their results and interpretation for application to database evaluation.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {70–76},
numpages = {7},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602270,
author = {Baru, C. K and Su, S. Y. W.},
title = {Performance Evaluation of the Statistical Aggregation by Categorization in the SM3 System},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602270},
doi = {10.1145/971697.602270},
abstract = {To perform a statistical aggregation operation over a large file often requires that the records of the file be divided into categories based on the values of the attribute(s) over which some statistical computation is to be performed. It is rather inefficient to perform the necessary data transfer, categorization and statistical computation using a single processor Parallel algorithms designed for multiprocessor systems have been proposed and their performance improvement over the conventional systems has been demonstrated. It is shown in this paper that three to four times performance improvement can be further gained by using a dynamically partitionable multicomputer system with switchable main memory modules (SM3).},
journal = {SIGMOD Rec.},
month = jun,
pages = {77–89},
numpages = {13}
}

@inproceedings{10.1145/602259.602270,
author = {Baru, C. K and Su, S. Y. W.},
title = {Performance Evaluation of the Statistical Aggregation by Categorization in the SM3 System},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602270},
doi = {10.1145/602259.602270},
abstract = {To perform a statistical aggregation operation over a large file often requires that the records of the file be divided into categories based on the values of the attribute(s) over which some statistical computation is to be performed. It is rather inefficient to perform the necessary data transfer, categorization and statistical computation using a single processor Parallel algorithms designed for multiprocessor systems have been proposed and their performance improvement over the conventional systems has been demonstrated. It is shown in this paper that three to four times performance improvement can be further gained by using a dynamically partitionable multicomputer system with switchable main memory modules (SM3).},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {77–89},
numpages = {13},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602272,
author = {Spooner, David L.},
title = {Database Support for Interactive Computer Graphics},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602272},
doi = {10.1145/971697.602272},
abstract = {Software applications involving interactive computer graphics are made up of several components. One of these is a data modeling component. This data modeling component is often application dependent and therefore difficult to integrate with the data model of other related applications. One solution to this problem is to interface a DBMS with an interactive graphics system to reduce data model dependency and increase sharing of data. This also has the advantage of allowing novice users to use computer graphics by eliminating the need for the user to write complex programs invoking the graphics system.This paper explores these ideas by discussing the implementation of a prototype interface between a relational DBMS and an interactive computer graphics system. It presents both the database structures used to manage the data and the techniques used to design the interface. It concludes by discussing an approach for making the interface portable.},
journal = {SIGMOD Rec.},
month = jun,
pages = {90–99},
numpages = {10}
}

@inproceedings{10.1145/602259.602272,
author = {Spooner, David L.},
title = {Database Support for Interactive Computer Graphics},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602272},
doi = {10.1145/602259.602272},
abstract = {Software applications involving interactive computer graphics are made up of several components. One of these is a data modeling component. This data modeling component is often application dependent and therefore difficult to integrate with the data model of other related applications. One solution to this problem is to interface a DBMS with an interactive graphics system to reduce data model dependency and increase sharing of data. This also has the advantage of allowing novice users to use computer graphics by eliminating the need for the user to write complex programs invoking the graphics system.This paper explores these ideas by discussing the implementation of a prototype interface between a relational DBMS and an interactive computer graphics system. It presents both the database structures used to manage the data and the techniques used to design the interface. It concludes by discussing an approach for making the interface portable.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {90–99},
numpages = {10},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602273,
author = {Fogg, Dennis},
title = {Lessons from a "Living in a Database" Graphical Query Interface},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602273},
doi = {10.1145/971697.602273},
abstract = {The Living In a Database system (LID) is a user-friendly interface to an entity-relationship database Its underlying ideas are similar to Cattell's PDB [Cattell 80], but its presentation is significantly different LID uses a bit-mapped graphics terminal with mouse pointer to create an attractive interaction environment. Experience from the implementation suggests that dynamic graphic displays --- those which have graphic symbols that change as the data they present change --- are an important feature in user interfaces but are difficult to implement with current technology The implementation also uncovers an important inadequacy in the PDB/LID idea the inability to operate on sets of data instances in the same way as individual data instances An extension to LID is suggested to alleviate the problem.},
journal = {SIGMOD Rec.},
month = jun,
pages = {100–106},
numpages = {7}
}

@inproceedings{10.1145/602259.602273,
author = {Fogg, Dennis},
title = {Lessons from a "Living in a Database" Graphical Query Interface},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602273},
doi = {10.1145/602259.602273},
abstract = {The Living In a Database system (LID) is a user-friendly interface to an entity-relationship database Its underlying ideas are similar to Cattell's PDB [Cattell 80], but its presentation is significantly different LID uses a bit-mapped graphics terminal with mouse pointer to create an attractive interaction environment. Experience from the implementation suggests that dynamic graphic displays --- those which have graphic symbols that change as the data they present change --- are an important feature in user interfaces but are difficult to implement with current technology The implementation also uncovers an important inadequacy in the PDB/LID idea the inability to operate on sets of data instances in the same way as individual data instances An extension to LID is suggested to alleviate the problem.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {100–106},
numpages = {7},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602275,
author = {Valduriez, Patrick and Viemont, Yann},
title = {A Multikey Hashing Scheme Using Predicate Trees},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602275},
doi = {10.1145/971697.602275},
abstract = {A new method for multikey access suitable for dynamic files is proposed that transforms multiple key values into a logical address This method is based on a new structure, called predicate tree, that represents the function applied to several keys A predicate tree permits to specify in a unified way various hashing schemes by allowing for different definitions of predicates A logical address qualifies a space partition of a file according to its predicate tree This address is seen as a single key by a digital hashing method which transforms it into a physical address This method is used to address records in a file and to transform a retrieval qualification on a file into a set of partitions to access Finally, a qualitative analysis of the behavior of the method is given which exhibits its value},
journal = {SIGMOD Rec.},
month = jun,
pages = {107–114},
numpages = {8}
}

@inproceedings{10.1145/602259.602275,
author = {Valduriez, Patrick and Viemont, Yann},
title = {A Multikey Hashing Scheme Using Predicate Trees},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602275},
doi = {10.1145/602259.602275},
abstract = {A new method for multikey access suitable for dynamic files is proposed that transforms multiple key values into a logical address This method is based on a new structure, called predicate tree, that represents the function applied to several keys A predicate tree permits to specify in a unified way various hashing schemes by allowing for different definitions of predicates A logical address qualifies a space partition of a file according to its predicate tree This address is seen as a single key by a digital hashing method which transforms it into a physical address This method is used to address records in a file and to transform a retrieval qualification on a file into a set of partitions to access Finally, a qualitative analysis of the behavior of the method is given which exhibits its value},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {107–114},
numpages = {8},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602276,
author = {Lum, V and Dadam, P and Erbe, R and Guenauer, J and Pistor, P and Walch, G and Werner, H and Woodfill, J},
title = {Designing DBMS Support for the Temporal Dimension},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602276},
doi = {10.1145/971697.602276},
journal = {SIGMOD Rec.},
month = jun,
pages = {115–130},
numpages = {16}
}

@inproceedings{10.1145/602259.602276,
author = {Lum, V and Dadam, P and Erbe, R and Guenauer, J and Pistor, P and Walch, G and Werner, H and Woodfill, J},
title = {Designing DBMS Support for the Temporal Dimension},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602276},
doi = {10.1145/602259.602276},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {115–130},
numpages = {16},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602277,
author = {Chen, Huei-huang and Kuck, Sharon McCure},
title = {Combining Relational and Network Retrieval Methods},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602277},
doi = {10.1145/971697.602277},
abstract = {New methods for retrieving records from a database with links are given so that records are retrieved only once and not multiple times as happens when using the traditional method of retrieval Improvements as great as 50 percent are expected for queries over databases containing only many-to-one relationships and much greater improvements are expected when many-to-many relationships are embedded in the database Furthermore, it is shown how to combine relational and network retrieval methods Relations, containing many tuples, are created during the evaluation of a network query Each relation is either joined with other relations or is used to continue the evaluation of the network query The methods given show how to optimize data retrieval from a relational database that is implemented using links, where each link represents a many-to-one relationship},
journal = {SIGMOD Rec.},
month = jun,
pages = {131–142},
numpages = {12}
}

@inproceedings{10.1145/602259.602277,
author = {Chen, Huei-huang and Kuck, Sharon McCure},
title = {Combining Relational and Network Retrieval Methods},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602277},
doi = {10.1145/602259.602277},
abstract = {New methods for retrieving records from a database with links are given so that records are retrieved only once and not multiple times as happens when using the traditional method of retrieval Improvements as great as 50 percent are expected for queries over databases containing only many-to-one relationships and much greater improvements are expected when many-to-many relationships are embedded in the database Furthermore, it is shown how to combine relational and network retrieval methods Relations, containing many tuples, are created during the evaluation of a network query Each relation is either joined with other relations or is used to continue the evaluation of the network query The methods given show how to optimize data retrieval from a relational database that is implemented using links, where each link represents a many-to-one relationship},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {131–142},
numpages = {12},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602279,
author = {Keller, Arthur M and Ullman, Jeffrey D},
title = {On Complementary and Independent Mappings on Databases},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602279},
doi = {10.1145/971697.602279},
abstract = {We define the notion of independent views to indicate whether the range values of the two views may be achieved independently The concept of complementary views indicates when the domain element can be uniquely determined by the range values of the two complementary views We consider the relationship between independent and complementary views In unrestricted domains, a view (but not the identity or empty view) can have more than one complementary, independent view Databases, however, are more restricted domains They are finite power sets A view is monotonic if it preserves inclusion However, in finite power sets when all views are monotonic, if a given view has another view which is independent and complementary, then this view is unique.},
journal = {SIGMOD Rec.},
month = jun,
pages = {143–148},
numpages = {6},
keywords = {view update, database theory, independent mappings, complementary mappings, relational databases}
}

@inproceedings{10.1145/602259.602279,
author = {Keller, Arthur M and Ullman, Jeffrey D},
title = {On Complementary and Independent Mappings on Databases},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602279},
doi = {10.1145/602259.602279},
abstract = {We define the notion of independent views to indicate whether the range values of the two views may be achieved independently The concept of complementary views indicates when the domain element can be uniquely determined by the range values of the two complementary views We consider the relationship between independent and complementary views In unrestricted domains, a view (but not the identity or empty view) can have more than one complementary, independent view Databases, however, are more restricted domains They are finite power sets A view is monotonic if it preserves inclusion However, in finite power sets when all views are monotonic, if a given view has another view which is independent and complementary, then this view is unique.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {143–148},
numpages = {6},
keywords = {independent mappings, relational databases, complementary mappings, database theory, view update},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602280,
author = {Chan, Edward P. F.},
title = {Optimal Computation of Total Projections with Unions of Simple Chase Join Expressions},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602280},
doi = {10.1145/971697.602280},
abstract = {The representative instance has been proposed as a query answering device in systems using the Universal Relation Interface. One approach is to use the total projections of the representative instance to generate the answer for a query. Associated with this approach is the problem of how to generate the total projections of the representative instance efficiently. We propose a generalization of extension joins, called chase join expressions, as a means to compute the total projections when functional dependencies are given as constraints. In particular, we identify an important subclass of chase join expressions called simple chase join expressions and show that the total projections with respect to a set of functional dependencies can be computed by unions of simple chase join expressions when an independent scheme is assumed. We also find a simple and efficient algorithm that minimizes the number of join operations in a union of simple chase join expressions.},
journal = {SIGMOD Rec.},
month = jun,
pages = {149–163},
numpages = {15}
}

@inproceedings{10.1145/602259.602280,
author = {Chan, Edward P. F.},
title = {Optimal Computation of Total Projections with Unions of Simple Chase Join Expressions},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602280},
doi = {10.1145/602259.602280},
abstract = {The representative instance has been proposed as a query answering device in systems using the Universal Relation Interface. One approach is to use the total projections of the representative instance to generate the answer for a query. Associated with this approach is the problem of how to generate the total projections of the representative instance efficiently. We propose a generalization of extension joins, called chase join expressions, as a means to compute the total projections when functional dependencies are given as constraints. In particular, we identify an important subclass of chase join expressions called simple chase join expressions and show that the total projections with respect to a set of functional dependencies can be computed by unions of simple chase join expressions when an independent scheme is assumed. We also find a simple and efficient algorithm that minimizes the number of join operations in a union of simple chase join expressions.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {149–163},
numpages = {15},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602281,
author = {Willard, Dan E},
title = {Efficient Processing of Relational Calculus Expressions Using Range Query Theory},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602281},
doi = {10.1145/971697.602281},
abstract = {In this paper we define a language based on a broad subset of the relational calculus and show all expressions in this language can be evaluated in space O(N) and time O(N logdN), where d is a small constant whose value depends on the particular predicate and where N is the number of records stored in the data base. We currently have no hard statistics, but a reasonable guess seems to be that a standard sequential random access machine can handle 95% or more of commercial requests in time O(N log N) and memory O(N) using this technique.},
journal = {SIGMOD Rec.},
month = jun,
pages = {164–175},
numpages = {12}
}

@inproceedings{10.1145/602259.602281,
author = {Willard, Dan E},
title = {Efficient Processing of Relational Calculus Expressions Using Range Query Theory},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602281},
doi = {10.1145/602259.602281},
abstract = {In this paper we define a language based on a broad subset of the relational calculus and show all expressions in this language can be evaluated in space O(N) and time O(N logdN), where d is a small constant whose value depends on the particular predicate and where N is the number of records stored in the data base. We currently have no hard statistics, but a reasonable guess seems to be that a standard sequential random access machine can handle 95% or more of commercial requests in time O(N log N) and memory O(N) using this technique.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {164–175},
numpages = {12},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602283,
author = {Boral, Haran and DeWitt, David J},
title = {A Methodology for Database System Performance Evaluation},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602283},
doi = {10.1145/971697.602283},
abstract = {This paper presents a methodology for evaluating the performance of database management systems and database machines in a multiuser environment. Three main factors that affect transaction throughput in a multiuser environment are identified: multiprogramming level, degree of data sharing among simultaneously executing transactions, and transaction mix. We demonstrate that only four basic query types are needed to construct a benchmark that will evaluate the performance of a system under a wide variety of workloads. Finally, we present the results of applying our techniques to the Britton-Lee IDM 500 database machine},
journal = {SIGMOD Rec.},
month = jun,
pages = {176–185},
numpages = {10}
}

@inproceedings{10.1145/602259.602283,
author = {Boral, Haran and DeWitt, David J},
title = {A Methodology for Database System Performance Evaluation},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602283},
doi = {10.1145/602259.602283},
abstract = {This paper presents a methodology for evaluating the performance of database management systems and database machines in a multiuser environment. Three main factors that affect transaction throughput in a multiuser environment are identified: multiprogramming level, degree of data sharing among simultaneously executing transactions, and transaction mix. We demonstrate that only four basic query types are needed to construct a benchmark that will evaluate the performance of a system under a wide variety of workloads. Finally, we present the results of applying our techniques to the Britton-Lee IDM 500 database machine},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {176–185},
numpages = {10},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602284,
author = {Kriegel, Hans-Peter},
title = {Performance Comparison of Index Structures for Multi-Key Retrieval},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602284},
doi = {10.1145/971697.602284},
abstract = {In this paper, we report on a performance comparison of four software implemented index structures for multi-key retrieval the inverted file, the grid file and two variants of multidimensional B-trees It turns out that the recently suggested structures multidimensional B-tree and grid file outperform the traditional inverted file},
journal = {SIGMOD Rec.},
month = jun,
pages = {186–196},
numpages = {11}
}

@inproceedings{10.1145/602259.602284,
author = {Kriegel, Hans-Peter},
title = {Performance Comparison of Index Structures for Multi-Key Retrieval},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602284},
doi = {10.1145/602259.602284},
abstract = {In this paper, we report on a performance comparison of four software implemented index structures for multi-key retrieval the inverted file, the grid file and two variants of multidimensional B-trees It turns out that the recently suggested structures multidimensional B-tree and grid file outperform the traditional inverted file},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {186–196},
numpages = {11},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602286,
author = {Motro, Amihai},
title = {Browsing in a Loosely Structured Database},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602286},
doi = {10.1145/971697.602286},
abstract = {Current database architectures emphasize structure and are inappropriate for applications which model environments that are subject to constant evolution, or environments which do not lend themselves to massive classifications In this paper we describe an architecture which promotes databases that are only loosely structured heaps of facts instead of highly structured data This architecture avoids the traditional dichotomy between "schema" and "data", and it incorporates a single mechanism for defining both inference rules and integrity constraints As lack of organization will usually have adverse effect on retrieval, the principal retrieval method for loosely structured databases is browsing exploratory searching which does not assume any knowledge of the organization (or even the very existence of organization) Two styles of browsing, called navigation and probing, are defined Both are derived from a standard query language based on predicate logic},
journal = {SIGMOD Rec.},
month = jun,
pages = {197–207},
numpages = {11}
}

@inproceedings{10.1145/602259.602286,
author = {Motro, Amihai},
title = {Browsing in a Loosely Structured Database},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602286},
doi = {10.1145/602259.602286},
abstract = {Current database architectures emphasize structure and are inappropriate for applications which model environments that are subject to constant evolution, or environments which do not lend themselves to massive classifications In this paper we describe an architecture which promotes databases that are only loosely structured heaps of facts instead of highly structured data This architecture avoids the traditional dichotomy between "schema" and "data", and it incorporates a single mechanism for defining both inference rules and integrity constraints As lack of organization will usually have adverse effect on retrieval, the principal retrieval method for loosely structured databases is browsing exploratory searching which does not assume any knowledge of the organization (or even the very existence of organization) Two styles of browsing, called navigation and probing, are defined Both are derived from a standard query language based on predicate logic},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {197–207},
numpages = {11},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602287,
author = {Stonebraker, Michael and Anderson, Erika and Hanson, Eric and Rubenstein, Brad},
title = {QUEL as a Data Type},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602287},
doi = {10.1145/971697.602287},
abstract = {This paper explores the use of commands in a query language as an abstract data type (ADT) in data base management systems Basically, an ADT facility allows new data types, such as polygons, lines, money, time, arrays of floating point numbers, bit vectors, etc, to supplement the built-in data types in a data base system. In this paper we demonstrate the power of adding a data type corresponding to commands in a query language We also propose three extensions to the query language QUEL to enhance its power in this augmented environment.},
journal = {SIGMOD Rec.},
month = jun,
pages = {208–214},
numpages = {7}
}

@inproceedings{10.1145/602259.602287,
author = {Stonebraker, Michael and Anderson, Erika and Hanson, Eric and Rubenstein, Brad},
title = {QUEL as a Data Type},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602287},
doi = {10.1145/602259.602287},
abstract = {This paper explores the use of commands in a query language as an abstract data type (ADT) in data base management systems Basically, an ADT facility allows new data types, such as polygons, lines, money, time, arrays of floating point numbers, bit vectors, etc, to supplement the built-in data types in a data base system. In this paper we demonstrate the power of adding a data type corresponding to commands in a query language We also propose three extensions to the query language QUEL to enhance its power in this augmented environment.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {208–214},
numpages = {7},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602289,
author = {Hogg, John and Gamvroulas, Stelios},
title = {An Active Mail System},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602289},
doi = {10.1145/971697.602289},
abstract = {Conventional electronic mail is passive text that is created, sent and read. Any further actions must be initiated by the recipient. By contrast, an "intelligent message" (imessage) is an active program that carries on a dialogue with the recipient. The imessage may subsequently route itself to other users as a result of the responses it receives, and it eventually returns these responses to the original sender.This paper describes a prototype intelligent mail system and discusses some of the problems involved in implementing such a system in a distributed environment.},
journal = {SIGMOD Rec.},
month = jun,
pages = {215–222},
numpages = {8}
}

@inproceedings{10.1145/602259.602289,
author = {Hogg, John and Gamvroulas, Stelios},
title = {An Active Mail System},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602289},
doi = {10.1145/602259.602289},
abstract = {Conventional electronic mail is passive text that is created, sent and read. Any further actions must be initiated by the recipient. By contrast, an "intelligent message" (imessage) is an active program that carries on a dialogue with the recipient. The imessage may subsequently route itself to other users as a result of the responses it receives, and it eventually returns these responses to the original sender.This paper describes a prototype intelligent mail system and discusses some of the problems involved in implementing such a system in a distributed environment.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {215–222},
numpages = {8},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602290,
author = {Chang, Jo-Mei},
title = {Simplifying Distributed Database Systems Design by Using a Broadcast Network},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602290},
doi = {10.1145/971697.602290},
abstract = {Atomic broadcast and failure detection are powerful primitives for distributed database systems In the distributed database system LAMBDA, they are provided as network primitives In this paper, we show how atomic broadcast and failure detection simplify transaction commitment, concurrency control, and crash recovery Specifically, we give a simple two-phase non-blocking commit protocol, whereas three phases are required in a point-to-point network We also give a simplified read-one/write-all update algorithm for replicated data and an easily implemented log-based recovery algorithm providing uninterrupted transaction processingThe benefits of performing the atomic broadcast and failure detection at the network level are also discussed Performing these functions at the network level not only simplifies database protocols but also better utilizes the broadcast network fewer messages are transmitted Comparisons between LAMBDA and existing distributed database systems are also made},
journal = {SIGMOD Rec.},
month = jun,
pages = {223–233},
numpages = {11}
}

@inproceedings{10.1145/602259.602290,
author = {Chang, Jo-Mei},
title = {Simplifying Distributed Database Systems Design by Using a Broadcast Network},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602290},
doi = {10.1145/602259.602290},
abstract = {Atomic broadcast and failure detection are powerful primitives for distributed database systems In the distributed database system LAMBDA, they are provided as network primitives In this paper, we show how atomic broadcast and failure detection simplify transaction commitment, concurrency control, and crash recovery Specifically, we give a simple two-phase non-blocking commit protocol, whereas three phases are required in a point-to-point network We also give a simplified read-one/write-all update algorithm for replicated data and an easily implemented log-based recovery algorithm providing uninterrupted transaction processingThe benefits of performing the atomic broadcast and failure detection at the network level are also discussed Performing these functions at the network level not only simplifies database protocols but also better utilizes the broadcast network fewer messages are transmitted Comparisons between LAMBDA and existing distributed database systems are also made},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {223–233},
numpages = {11},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602291,
author = {Fishman, Daniel H and Lai, Ming-Yee and Wilkinson, W Kevin},
title = {Overview of the Jasmin Database Machine},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602291},
doi = {10.1145/971697.602291},
abstract = {The Jasmin database machine is being implemented as part of a research project in distributed processing and database management A primary goal of the work is to demonstrate the feasibility of a practical multiprocessor database machine suitable for large database, high transaction-rate applications Key features of Jasmin are its configurable performance, its use of off-the-shelf parts, and its ability to handle distributed databases A uniprocessor prototype of Jasmin has already been completed and the multiprocessor version is planned for later this year In this paper we describe Jasmin's architecture and discuss the performance observed in the uniprocessor prototype},
journal = {SIGMOD Rec.},
month = jun,
pages = {234–239},
numpages = {6}
}

@inproceedings{10.1145/602259.602291,
author = {Fishman, Daniel H and Lai, Ming-Yee and Wilkinson, W Kevin},
title = {Overview of the Jasmin Database Machine},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602291},
doi = {10.1145/602259.602291},
abstract = {The Jasmin database machine is being implemented as part of a research project in distributed processing and database management A primary goal of the work is to demonstrate the feasibility of a practical multiprocessor database machine suitable for large database, high transaction-rate applications Key features of Jasmin are its configurable performance, its use of off-the-shelf parts, and its ability to handle distributed databases A uniprocessor prototype of Jasmin has already been completed and the multiprocessor version is planned for later this year In this paper we describe Jasmin's architecture and discuss the performance observed in the uniprocessor prototype},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {234–239},
numpages = {6},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602293,
author = {Shmueli, Oded and Itai, Alon},
title = {Maintenance of Views},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602293},
doi = {10.1145/971697.602293},
abstract = {In relational databases a view definition is a query against the database, and a view materialization is the result of applying the view definition to the current database A view materialization over a database may change as relations in the database undergo modificationsIn this paper a mechanism is proposed in which the view is materialized at all times The problem which this mechanism addresses is how to quickly update the view in response to database changes A structure is maintained which provides information useful in minimizing the amount of work caused by updatesMethods are presented for handling both general databases and the much simpler tree databases (also called acyclic database) In both cases adding or deleting a tuple can be performed in polynomial time For tree databases the degree of the polynomial is independent of the schema structure while for cyclic databases the degree depends on the schema structure The cost of a sequence of tuple additions (deletions) is also analyzed},
journal = {SIGMOD Rec.},
month = jun,
pages = {240–255},
numpages = {16}
}

@inproceedings{10.1145/602259.602293,
author = {Shmueli, Oded and Itai, Alon},
title = {Maintenance of Views},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602293},
doi = {10.1145/602259.602293},
abstract = {In relational databases a view definition is a query against the database, and a view materialization is the result of applying the view definition to the current database A view materialization over a database may change as relations in the database undergo modificationsIn this paper a mechanism is proposed in which the view is materialized at all times The problem which this mechanism addresses is how to quickly update the view in response to database changes A structure is maintained which provides information useful in minimizing the amount of work caused by updatesMethods are presented for handling both general databases and the much simpler tree databases (also called acyclic database) In both cases adding or deleting a tuple can be performed in polynomial time For tree databases the degree of the polynomial is independent of the schema structure while for cyclic databases the degree depends on the schema structure The cost of a sequence of tuple additions (deletions) is also analyzed},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {240–255},
numpages = {16},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602294,
author = {Piatetsky-Shapiro, Gregory and Connell, Charles},
title = {Accurate Estimation of the Number of Tuples Satisfying a Condition},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602294},
doi = {10.1145/971697.602294},
abstract = {We present a new method for estimating the number of tuples satisfying a condition of the type attribute rel constant, where rel is one of "=", "&gt;", "&lt;", "≥", "≤". Our method gives highly accurate, yet easy to compute, estimates. We store information about attribute values as a list of distribution steps (histograms where buckets, instead of having equal width, have equal height). These distribution steps provide an upper bound on the error when estimating the number of tuples satisfying a condition. The estimation error can be arbitrarily reduced by increasing the number of steps. We analyze desirable conditions that such estimates should satisfy. Based on the distribution steps, we derive a set of estimation formulas which minimize the worst-case error. We also present another set of formulas which reduce the average-case error. Finally, we show how to use sampling to compute a close approximation of the distribution steps very quickly. The major applications of our method are in query optimization and in answering statistical queries.},
journal = {SIGMOD Rec.},
month = jun,
pages = {256–276},
numpages = {21}
}

@inproceedings{10.1145/602259.602294,
author = {Piatetsky-Shapiro, Gregory and Connell, Charles},
title = {Accurate Estimation of the Number of Tuples Satisfying a Condition},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602294},
doi = {10.1145/602259.602294},
abstract = {We present a new method for estimating the number of tuples satisfying a condition of the type attribute rel constant, where rel is one of "=", "&gt;", "&lt;", "≥", "≤". Our method gives highly accurate, yet easy to compute, estimates. We store information about attribute values as a list of distribution steps (histograms where buckets, instead of having equal width, have equal height). These distribution steps provide an upper bound on the error when estimating the number of tuples satisfying a condition. The estimation error can be arbitrarily reduced by increasing the number of steps. We analyze desirable conditions that such estimates should satisfy. Based on the distribution steps, we derive a set of estimation formulas which minimize the worst-case error. We also present another set of formulas which reduce the average-case error. Finally, we show how to use sampling to compute a close approximation of the distribution steps very quickly. The major applications of our method are in query optimization and in answering statistical queries.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {256–276},
numpages = {21},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602295,
author = {Salton, Gerard},
title = {The Use of Extended Boolean Logic in Information Retrieval},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602295},
doi = {10.1145/971697.602295},
abstract = {An extended Boolean retrieval strategy has previously been introduced in which the individual Boolean operators can be treated more or less strictly, depending on the perceived strength of association of the query terms. The extended Boolean system is illustrated by examples and evaluation output is used to demonstrate the effectiveness of the operations.},
journal = {SIGMOD Rec.},
month = jun,
pages = {277–285},
numpages = {9}
}

@inproceedings{10.1145/602259.602295,
author = {Salton, Gerard},
title = {The Use of Extended Boolean Logic in Information Retrieval},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602295},
doi = {10.1145/602259.602295},
abstract = {An extended Boolean retrieval strategy has previously been introduced in which the individual Boolean operators can be treated more or less strictly, depending on the perceived strength of association of the query terms. The extended Boolean system is illustrated by examples and evaluation output is used to demonstrate the effectiveness of the operations.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {277–285},
numpages = {9},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602297,
author = {Tsur, Shalom and Zaniolo, Carlo},
title = {An Implementation of GEM: Supporting a Semantic Data Model on a Relational Back-End.},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602297},
doi = {10.1145/971697.602297},
abstract = {This paper presents a simple approach for extending the relational system INGRES into one supporting a semantic data model it describe a DBMS consisting of (i) a user-friendly front-end, supporting the GEM semantic data model and query language under the UNIX time-sharing system, and (ii) a dedicated back-end processor providing efficient support for database transactions, concurrency control and recovery GEM extends the relational model to support the notions of entities with surrogates, the relationships of aggregation and generalization, null values and set-valued attributes, and provides simple extensions of QUEL to handle these new constructs in this proposed implementation of GEM, the relational database processor IDM 500 by Britton-Lee is used as the back-end machine},
journal = {SIGMOD Rec.},
month = jun,
pages = {286–295},
numpages = {10}
}

@inproceedings{10.1145/602259.602297,
author = {Tsur, Shalom and Zaniolo, Carlo},
title = {An Implementation of GEM: Supporting a Semantic Data Model on a Relational Back-End.},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602297},
doi = {10.1145/602259.602297},
abstract = {This paper presents a simple approach for extending the relational system INGRES into one supporting a semantic data model it describe a DBMS consisting of (i) a user-friendly front-end, supporting the GEM semantic data model and query language under the UNIX time-sharing system, and (ii) a dedicated back-end processor providing efficient support for database transactions, concurrency control and recovery GEM extends the relational model to support the notions of entities with surrogates, the relationships of aggregation and generalization, null values and set-valued attributes, and provides simple extensions of QUEL to handle these new constructs in this proposed implementation of GEM, the relational database processor IDM 500 by Britton-Lee is used as the back-end machine},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {286–295},
numpages = {10},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602298,
author = {Jarke, Matthias and Clifford, Jim and Vassiliou, Yannis},
title = {An Optimizing Prolog Front-End to a Relational Query System},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602298},
doi = {10.1145/971697.602298},
abstract = {An optimizing translation mechanism for the dynamic interaction between a logic-based expert system written in PROLOG and a relational database accessible through SQL is presented. The mechanism makes use of an intermediate language that decomposes the optimization problem and makes the proposed approach target-language independent. It can either facilitate expert system - database interaction, e.g., when integrating expert systems into business systems, or augment existing databases with (external) deductive capabilities.},
journal = {SIGMOD Rec.},
month = jun,
pages = {296–306},
numpages = {11}
}

@inproceedings{10.1145/602259.602298,
author = {Jarke, Matthias and Clifford, Jim and Vassiliou, Yannis},
title = {An Optimizing Prolog Front-End to a Relational Query System},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602298},
doi = {10.1145/602259.602298},
abstract = {An optimizing translation mechanism for the dynamic interaction between a logic-based expert system written in PROLOG and a relational database accessible through SQL is presented. The mechanism makes use of an intermediate language that decomposes the optimization problem and makes the proposed approach target-language independent. It can either facilitate expert system - database interaction, e.g., when integrating expert systems into business systems, or augment existing databases with (external) deductive capabilities.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {296–306},
numpages = {11},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602299,
author = {Shepherd, Allan and Kerschberg, Larry},
title = {Prism: A Knowledge Based System for Semantic Integrity Specification and Enforcement in Database Systems},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602299},
doi = {10.1145/971697.602299},
abstract = {This paper presents a knowledge-based approach to the specification, design, implementation, and evolution of database applications The knowledge base consists of 1) facts regarding database objects that are organized into a hierarchy of models, and 2) rules that specify the behavior of objects within a model and among modelsThe model hierarchy consists of database application data, database schemas, data model definitions, and system-related objects that control the user's interaction with the system The rules governing the behavior of objects are specified as explicit constraints on those objects User goals are transformed into conjectures that the inference engine must prove are satisfiable by interpreting all applicable constraintsThe semantic architecture of the PRISM system is described, together with the syntax and semantics of the constraint language PRISM is implemented in the C programming language and runs under the UNIX ** operating system},
journal = {SIGMOD Rec.},
month = jun,
pages = {307–315},
numpages = {9}
}

@inproceedings{10.1145/602259.602299,
author = {Shepherd, Allan and Kerschberg, Larry},
title = {Prism: A Knowledge Based System for Semantic Integrity Specification and Enforcement in Database Systems},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602299},
doi = {10.1145/602259.602299},
abstract = {This paper presents a knowledge-based approach to the specification, design, implementation, and evolution of database applications The knowledge base consists of 1) facts regarding database objects that are organized into a hierarchy of models, and 2) rules that specify the behavior of objects within a model and among modelsThe model hierarchy consists of database application data, database schemas, data model definitions, and system-related objects that control the user's interaction with the system The rules governing the behavior of objects are specified as explicit constraints on those objects User goals are transformed into conjectures that the inference engine must prove are satisfiable by interpreting all applicable constraintsThe semantic architecture of the PRISM system is described, together with the syntax and semantics of the constraint language PRISM is implemented in the C programming language and runs under the UNIX ** operating system},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {307–315},
numpages = {9},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602300,
author = {Copeland, George and Maier, David},
title = {Making Smalltalk a Database System},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602300},
doi = {10.1145/971697.602300},
abstract = {To overcome limitations in the modeling power of existing database systems and provide a better tool for database application programming, Servio Logic Corporation is developing a computer system to support a set-theoretic data model in an object-oriented programming environment We recount the problems with existing models and database systems We then show how features of Smalltalk, such such as operational semantics, its type hierarchy, entity identity and the merging of programming and data language, solve many of those problems Nest we consider what Smalltalk lacks as a database system secondary storage management, a declarative semantics, concurrency, past states To address these shortcomings, we needed a formal data model We introduce the GemStone data model, and show how it helps to define path expressions, a declarative semantics and object history in the OPAL language We summarize similar approaches, and give a brief overview of the GemStone system implementation},
journal = {SIGMOD Rec.},
month = jun,
pages = {316–325},
numpages = {10}
}

@inproceedings{10.1145/602259.602300,
author = {Copeland, George and Maier, David},
title = {Making Smalltalk a Database System},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602300},
doi = {10.1145/602259.602300},
abstract = {To overcome limitations in the modeling power of existing database systems and provide a better tool for database application programming, Servio Logic Corporation is developing a computer system to support a set-theoretic data model in an object-oriented programming environment We recount the problems with existing models and database systems We then show how features of Smalltalk, such such as operational semantics, its type hierarchy, entity identity and the merging of programming and data language, solve many of those problems Nest we consider what Smalltalk lacks as a database system secondary storage management, a declarative semantics, concurrency, past states To address these shortcomings, we needed a formal data model We introduce the GemStone data model, and show how it helps to define path expressions, a declarative semantics and object history in the OPAL language We summarize similar approaches, and give a brief overview of the GemStone system implementation},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {316–325},
numpages = {10},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

@article{10.1145/971697.602301,
author = {Hall, Patrick A. V.},
title = {Relational Algebras, Logic, and Functional Programming},
year = {1984},
issue_date = {June 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/971697.602301},
doi = {10.1145/971697.602301},
abstract = {Relational algebras as developed by Codd and his followers are extended by noting an equivalence with functional languages. This leads to higher order relations, recursive definitions of relations, and the use of higher order relations as recursive data structures. This equivalence on the one hand enables the technology of databases to be used within the context of applicative languages, and on the other hand removes the adhoc mechanisms used for higher order operations in relational databases. This leads from 4th to 5th generation data management, exploiting the mathematical foundations of functional languages and logic programming, and the technology of relational database.},
journal = {SIGMOD Rec.},
month = jun,
pages = {326–333},
numpages = {8}
}

@inproceedings{10.1145/602259.602301,
author = {Hall, Patrick A. V.},
title = {Relational Algebras, Logic, and Functional Programming},
year = {1984},
isbn = {0897911288},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/602259.602301},
doi = {10.1145/602259.602301},
abstract = {Relational algebras as developed by Codd and his followers are extended by noting an equivalence with functional languages. This leads to higher order relations, recursive definitions of relations, and the use of higher order relations as recursive data structures. This equivalence on the one hand enables the technology of databases to be used within the context of applicative languages, and on the other hand removes the adhoc mechanisms used for higher order operations in relational databases. This leads from 4th to 5th generation data management, exploiting the mathematical foundations of functional languages and logic programming, and the technology of relational database.},
booktitle = {Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data},
pages = {326–333},
numpages = {8},
location = {Boston, Massachusetts},
series = {SIGMOD '84}
}

