@inproceedings{10.1145/317456.317457,
author = {Tombaugh, Jo W. and Arkin, Michael D. and Dillion, Richard F.},
title = {The Effect of VDU Text-Presentation Rate on Reading Comprehension and Reading Speed},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317457},
doi = {10.1145/317456.317457},
abstract = {The effect of video display unit presentation rate on reading performance was investigated. Reading material was presented at one of the following presentation-rates: 15, 30, 120, 960 cps, or “instant”. In the instant condition, the full text appeared simultaneously on the screen. In the other conditions, text appeared one character at a time starting in the upper left corner of the screen, from left to right and top to bottom. Reading comprehension was highest under the 30 cps and instant presentation conditions. Total time to perform the reading task was equivalent for all conditions except the 15 cps rate which required a longer time to complete the task. In terms of comprehension and time to perform the task, a slow rate of 15 cps, contrary to previous recommendations, is not desirable for novice computer users.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {1–6},
numpages = {6},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317457,
author = {Tombaugh, Jo W. and Arkin, Michael D. and Dillion, Richard F.},
title = {The Effect of VDU Text-Presentation Rate on Reading Comprehension and Reading Speed},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317457},
doi = {10.1145/1165385.317457},
abstract = {The effect of video display unit presentation rate on reading performance was investigated. Reading material was presented at one of the following presentation-rates: 15, 30, 120, 960 cps, or “instant”. In the instant condition, the full text appeared simultaneously on the screen. In the other conditions, text appeared one character at a time starting in the upper left corner of the screen, from left to right and top to bottom. Reading comprehension was highest under the 30 cps and instant presentation conditions. Total time to perform the reading task was equivalent for all conditions except the 15 cps rate which required a longer time to complete the task. In terms of comprehension and time to perform the task, a slow rate of 15 cps, contrary to previous recommendations, is not desirable for novice computer users.},
journal = {SIGCHI Bull.},
month = apr,
pages = {1–6},
numpages = {6}
}

@inproceedings{10.1145/317456.317458,
author = {Gould, John D. and Lewis, Clayton and Barnes, Vincent},
title = {Effects of Cursor Speed on Text-Editing},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317458},
doi = {10.1145/317456.317458},
abstract = {Nine participants used a full screen computer text-editor (XEDIT) with an IBM 3277 terminal to edit marked-up documents at each of three cursor speeds (3.3, 4.7, and 11.0 cm/sec.). Results show that 9% of editing time was spent controlling and moving the cursor, regardless of cursor speed. The variations in cursor speed studied did not seem to act as a pacing device for the entire editing task.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {7–10},
numpages = {4},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317458,
author = {Gould, John D. and Lewis, Clayton and Barnes, Vincent},
title = {Effects of Cursor Speed on Text-Editing},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317458},
doi = {10.1145/1165385.317458},
abstract = {Nine participants used a full screen computer text-editor (XEDIT) with an IBM 3277 terminal to edit marked-up documents at each of three cursor speeds (3.3, 4.7, and 11.0 cm/sec.). Results show that 9% of editing time was spent controlling and moving the cursor, regardless of cursor speed. The variations in cursor speed studied did not seem to act as a pacing device for the entire editing task.},
journal = {SIGCHI Bull.},
month = apr,
pages = {7–10},
numpages = {4}
}

@inproceedings{10.1145/317456.317459,
author = {Myers, Brad A.},
title = {The Importance of Percent-Done Progress Indicators for Computer-Human Interfaces},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317459},
doi = {10.1145/317456.317459},
abstract = {A “percent-done progress indicator” is a graphical technique which allows the user to monitor the progress through the processing of a task. Progress indicators can be displayed on almost all types of output devices, and can be used with many different kinds of programs. Practical experience and formal experiments show that prograss indicators are an important and useful user-interface tool, and that they enhance the attractiveness and effectiveness of programs that incorporate them. This paper discusses why progress indicators are important. It includes the results of a formal experiment with progress indicators. One part of the experiment demonstrates that people prefer to have progress indicators. Another part attempted to replicate earlier findings to show that people prefer constant to variable response time in general, and then to show that this effect is reversed with progress indicators, but the results were not statistically significant. In fact, no significant preference for constant response time was shown, contrary to previously published results.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {11–17},
numpages = {7},
keywords = {progress indicators, window managers, user interfaces},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317459,
author = {Myers, Brad A.},
title = {The Importance of Percent-Done Progress Indicators for Computer-Human Interfaces},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317459},
doi = {10.1145/1165385.317459},
abstract = {A “percent-done progress indicator” is a graphical technique which allows the user to monitor the progress through the processing of a task. Progress indicators can be displayed on almost all types of output devices, and can be used with many different kinds of programs. Practical experience and formal experiments show that prograss indicators are an important and useful user-interface tool, and that they enhance the attractiveness and effectiveness of programs that incorporate them. This paper discusses why progress indicators are important. It includes the results of a formal experiment with progress indicators. One part of the experiment demonstrates that people prefer to have progress indicators. Another part attempted to replicate earlier findings to show that people prefer constant to variable response time in general, and then to show that this effect is reversed with progress indicators, but the results were not statistically significant. In fact, no significant preference for constant response time was shown, contrary to previously published results.},
journal = {SIGCHI Bull.},
month = apr,
pages = {11–17},
numpages = {7},
keywords = {user interfaces, window managers, progress indicators}
}

@inproceedings{10.1145/317456.317460,
author = {Hayes, Philip J.},
title = {The Utility of Natural Language Interfaces (Panel Session)},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317460},
doi = {10.1145/317456.317460},
abstract = {Natural language interfaces are frequently proposed as a solution to the problems of “user-unfriendliness” present in many existing computer system interfaces. The panel will examine this claim, and discuss in what circumstances (if any) it is (or could be) true.As a starting point, let us define a natural language interface as an interface to a computer system that allows the user to control the system by English1 commands or queries. Sometimes the output seen by the user will also be in natural language. Currently, most natural language interfaces only accept typed, rather than spoken, input. Also, such interfaces typically can only handle input related to the restricted world of their underlying application, and moreover, only a subset (albeit expressively comprehensive) of that.Set against these advantages are the following standardly cited disadvantages:verboseness: English commands or queries can take many more keystrokes to enter than equivalent formal command lines or menu-based selection.coverage restrictions: Since current natural language interfaces cannot handle all natural language inputs, not even all those relevant to their domain of discourse, the user is faced with the task of learning what the system can and cannot deal with, usually by trial and error.Given these conflicting arguments, it seems better to avoid the general question of whether natural language interfaces are Good or Bad. Instead, the panel will concentrate on how the utility of natural language interfaces is affected by the environment (broadly conceived) in which they operate. We will also be concerned with how the utility of specific natural language or other types of interface can be determined in specific circumstances.Factors affecting the utility of natural language interfaces include:Type of user: Natural language interfaces are better suited to novice or casual users rather than expert or frequent users of a system. An expert or frequent user can afford the cost of learning a command language because of the terseness it allows. On the other hand, it may be more economical for a novice or infrequent user to enter a verbose natural language input than to find out the correct terse command line.Combination with other input types: It may be possible to build interfaces which combine natural language and other types of interface in way that retains the best features of both, while reducing the impact of their negative features.The above list of issues does not pretend to be comprehensive, out is intended as a basis for discussion. Many other issues will no doubt arise during the course of the panel.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {19},
numpages = {1},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317460,
author = {Hayes, Philip J.},
title = {The Utility of Natural Language Interfaces (Panel Session)},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317460},
doi = {10.1145/1165385.317460},
abstract = {Natural language interfaces are frequently proposed as a solution to the problems of “user-unfriendliness” present in many existing computer system interfaces. The panel will examine this claim, and discuss in what circumstances (if any) it is (or could be) true.As a starting point, let us define a natural language interface as an interface to a computer system that allows the user to control the system by English1 commands or queries. Sometimes the output seen by the user will also be in natural language. Currently, most natural language interfaces only accept typed, rather than spoken, input. Also, such interfaces typically can only handle input related to the restricted world of their underlying application, and moreover, only a subset (albeit expressively comprehensive) of that.Set against these advantages are the following standardly cited disadvantages:verboseness: English commands or queries can take many more keystrokes to enter than equivalent formal command lines or menu-based selection.coverage restrictions: Since current natural language interfaces cannot handle all natural language inputs, not even all those relevant to their domain of discourse, the user is faced with the task of learning what the system can and cannot deal with, usually by trial and error.Given these conflicting arguments, it seems better to avoid the general question of whether natural language interfaces are Good or Bad. Instead, the panel will concentrate on how the utility of natural language interfaces is affected by the environment (broadly conceived) in which they operate. We will also be concerned with how the utility of specific natural language or other types of interface can be determined in specific circumstances.Factors affecting the utility of natural language interfaces include:Type of user: Natural language interfaces are better suited to novice or casual users rather than expert or frequent users of a system. An expert or frequent user can afford the cost of learning a command language because of the terseness it allows. On the other hand, it may be more economical for a novice or infrequent user to enter a verbose natural language input than to find out the correct terse command line.Combination with other input types: It may be possible to build interfaces which combine natural language and other types of interface in way that retains the best features of both, while reducing the impact of their negative features.The above list of issues does not pretend to be comprehensive, out is intended as a basis for discussion. Many other issues will no doubt arise during the course of the panel.},
journal = {SIGCHI Bull.},
month = apr,
pages = {19},
numpages = {1}
}

@inproceedings{10.1145/317456.317461,
author = {Lee, SK and Buxton, William and Smith, K. C.},
title = {A Multi-Touch Three Dimensional Touch-Sensitive Tablet},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317461},
doi = {10.1145/317456.317461},
abstract = {A prototype touch-sensitive tablet is presented. The tablet's main innovation is that it is capable of sensing more than one point of contact at a time. In addition to being able to provide position coordinates, the tablet also gives a measure of degree of contact, independently for each point of contact. In order to enable multi-touch sensing, the tablet surface is divided into a grid of discrete points. The points are scanned using a recursive area subdivision algorithm. In order to minimize the resolution lost due to the discrete nature of the grid, a novel interpolation scheme has been developed. Finally, the paper briefly discusses how multi-touch sensing, interpolation, and degree of contact sensing can be combined to expand our vocabulary in human-computer interaction.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {21–25},
numpages = {5},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317461,
author = {Lee, SK and Buxton, William and Smith, K. C.},
title = {A Multi-Touch Three Dimensional Touch-Sensitive Tablet},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317461},
doi = {10.1145/1165385.317461},
abstract = {A prototype touch-sensitive tablet is presented. The tablet's main innovation is that it is capable of sensing more than one point of contact at a time. In addition to being able to provide position coordinates, the tablet also gives a measure of degree of contact, independently for each point of contact. In order to enable multi-touch sensing, the tablet surface is divided into a grid of discrete points. The points are scanned using a recursive area subdivision algorithm. In order to minimize the resolution lost due to the discrete nature of the grid, a novel interpolation scheme has been developed. Finally, the paper briefly discusses how multi-touch sensing, interpolation, and degree of contact sensing can be combined to expand our vocabulary in human-computer interaction.},
journal = {SIGCHI Bull.},
month = apr,
pages = {21–25},
numpages = {5}
}

@inproceedings{10.1145/317456.317462,
author = {Atherton, Peter R. and Caporael, Linnda R.},
title = {A Subjective Judgment Study of Polygon Based Curved Surface Imagery},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317462},
doi = {10.1145/317456.317462},
abstract = {In the past computer graphics efforts, several researchers have demonstrated that polygon models can be used to produce images of curved surfaces that appear to be smooth and accurate. However, the authors know of no attempt to appraise such imagery by using multiple human observation ratings.The effectiveness of curved surface imagery generated from polygon models was investigated in a judgment study. Research subjects evaluated sphere model imagery derived from several polygon densities and shading procedures including flat shading, shade interpolation (Gouraud) and normal interpolation (Phong). Results of the evaluations indicated that little was gained by reducing the average polygon areas below approximately 110 pixels per polygon for spheres of 95 pixel radii displayed on a 512 x 512 resolution monitor. Evaluations for both shade and normal interpolution placed polygon image quality reasonably close to an “ideal” image. Although the evaluations indicated that normal interpolation was slightly superior to the shade interpolation, shade interpolation required significantly less computation. Most significantly, results from this study provide strong support for the notion that polygons can be used effectively to produce smooth shaded imagery of curved surface models.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {27–34},
numpages = {8},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317462,
author = {Atherton, Peter R. and Caporael, Linnda R.},
title = {A Subjective Judgment Study of Polygon Based Curved Surface Imagery},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317462},
doi = {10.1145/1165385.317462},
abstract = {In the past computer graphics efforts, several researchers have demonstrated that polygon models can be used to produce images of curved surfaces that appear to be smooth and accurate. However, the authors know of no attempt to appraise such imagery by using multiple human observation ratings.The effectiveness of curved surface imagery generated from polygon models was investigated in a judgment study. Research subjects evaluated sphere model imagery derived from several polygon densities and shading procedures including flat shading, shade interpolation (Gouraud) and normal interpolation (Phong). Results of the evaluations indicated that little was gained by reducing the average polygon areas below approximately 110 pixels per polygon for spheres of 95 pixel radii displayed on a 512 x 512 resolution monitor. Evaluations for both shade and normal interpolution placed polygon image quality reasonably close to an “ideal” image. Although the evaluations indicated that normal interpolation was slightly superior to the shade interpolation, shade interpolation required significantly less computation. Most significantly, results from this study provide strong support for the notion that polygons can be used effectively to produce smooth shaded imagery of curved surface models.},
journal = {SIGCHI Bull.},
month = apr,
pages = {27–34},
numpages = {8}
}

@inproceedings{10.1145/317456.317463,
author = {Krueger, Myron W. and Gionfriddo, Thomas and Hinrichsen, Katrin},
title = {VIDEOPLACE—an Artificial Reality},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317463},
doi = {10.1145/317456.317463},
abstract = {The human-machine interface is generalized beyond traditional control devices to permit physical participation with graphic images. The VIDEOPLACE System combines a participant's live video image with a computer graphic world. It also coordinates the behavior of graphic objects and creatures so that they appear to react to the movements of the participant's image in real-time. A prototype system has been implemented and a number of experiments with aesthetic and practical implications have been conducted.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {35–40},
numpages = {6},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317463,
author = {Krueger, Myron W. and Gionfriddo, Thomas and Hinrichsen, Katrin},
title = {VIDEOPLACE—an Artificial Reality},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317463},
doi = {10.1145/1165385.317463},
abstract = {The human-machine interface is generalized beyond traditional control devices to permit physical participation with graphic images. The VIDEOPLACE System combines a participant's live video image with a computer graphic world. It also coordinates the behavior of graphic objects and creatures so that they appear to react to the movements of the participant's image in real-time. A prototype system has been implemented and a number of experiments with aesthetic and practical implications have been conducted.},
journal = {SIGCHI Bull.},
month = apr,
pages = {35–40},
numpages = {6}
}

@inproceedings{10.1145/317456.317464,
author = {Gould, John D. and Anderson, John A. and Barnard, Phil and Landauer, Thomas K.},
title = {Psychological Research Methods in the Human Use of Computers (Panel Session)},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317464},
doi = {10.1145/317456.317464},
abstract = {Psychological research methods have been used with increasing frequency in work on computer-human interaction. Judging from the state of the literature and from remarks heard in the halls at conferences such as this, the utility and appropriate roles of such methods are not yet clear. Panel members, who are all research psychologists working on issues related to human use of computers, will present a variety of contrasting views on how to go about such research, and on its proper goals. John Gould will describe two different but complimentary approaches, applied research on general design issues, and formative human factors participation in development. John Anderson will discuss the use of formal models of human cognition. Phil Barnard will consider the role of applied research in the discovery of underlying principles to guide design. Tom Landauer will propose that psychological research can be the basis for invention of new “;cognitive tools”. Short synopses of the positions they will take e given below. Panel members hope that the audience will join them in bringing out important differences between the various approaches and methods and arguing their absolute and relative merits.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {41–45},
numpages = {5},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317464,
author = {Gould, John D. and Anderson, John A. and Barnard, Phil and Landauer, Thomas K.},
title = {Psychological Research Methods in the Human Use of Computers (Panel Session)},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317464},
doi = {10.1145/1165385.317464},
abstract = {Psychological research methods have been used with increasing frequency in work on computer-human interaction. Judging from the state of the literature and from remarks heard in the halls at conferences such as this, the utility and appropriate roles of such methods are not yet clear. Panel members, who are all research psychologists working on issues related to human use of computers, will present a variety of contrasting views on how to go about such research, and on its proper goals. John Gould will describe two different but complimentary approaches, applied research on general design issues, and formative human factors participation in development. John Anderson will discuss the use of formal models of human cognition. Phil Barnard will consider the role of applied research in the discovery of underlying principles to guide design. Tom Landauer will propose that psychological research can be the basis for invention of new “;cognitive tools”. Short synopses of the positions they will take e given below. Panel members hope that the audience will join them in bringing out important differences between the various approaches and methods and arguing their absolute and relative merits.},
journal = {SIGCHI Bull.},
month = apr,
pages = {41–45},
numpages = {5}
}

@inproceedings{10.1145/317456.317465,
author = {Spohrer, James C. and Soloway, Elliot and Pope, Edgar},
title = {Where the Bugs Are},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317465},
doi = {10.1145/317456.317465},
abstract = {In this paper we propose one explanation of why some novice programs are buggier than others. Central to our explanation is the notion of merged goals/plans in which multiple goals are achieved in a single integrated plan. Our arguments are based on our theory of the knowledge — plans and goals — used by a novice in creating a program, and an analysis of actual buggy novice programs.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {47–53},
numpages = {7},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317465,
author = {Spohrer, James C. and Soloway, Elliot and Pope, Edgar},
title = {Where the Bugs Are},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317465},
doi = {10.1145/1165385.317465},
abstract = {In this paper we propose one explanation of why some novice programs are buggier than others. Central to our explanation is the notion of merged goals/plans in which multiple goals are achieved in a single integrated plan. Our arguments are based on our theory of the knowledge — plans and goals — used by a novice in creating a program, and an analysis of actual buggy novice programs.},
journal = {SIGCHI Bull.},
month = apr,
pages = {47–53},
numpages = {7}
}

@inproceedings{10.1145/317456.317466,
author = {Lewis, Clayton},
title = {Extending the Spreadsheet Interface to Handle Approximate Quantities and Relationships},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317466},
doi = {10.1145/317456.317466},
abstract = {Conventional spreadsheet programs offer a very convenient user interface for many quantitative tasks, but they are restricted to handling precisely-specified quantities and calculations. ASP is a generalized spreadsheet that extends the basic spreadsheet paradigm to encompass quantities which are not known exactly, and functions which are not known well enough to permit calculation. ASP works by propagating assertions about quantities and functions through the network of relationships that the spreadsheet defines.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {55–59},
numpages = {5},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317466,
author = {Lewis, Clayton},
title = {Extending the Spreadsheet Interface to Handle Approximate Quantities and Relationships},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317466},
doi = {10.1145/1165385.317466},
abstract = {Conventional spreadsheet programs offer a very convenient user interface for many quantitative tasks, but they are restricted to handling precisely-specified quantities and calculations. ASP is a generalized spreadsheet that extends the basic spreadsheet paradigm to encompass quantities which are not known exactly, and functions which are not known well enough to permit calculation. ASP works by propagating assertions about quantities and functions through the network of relationships that the spreadsheet defines.},
journal = {SIGCHI Bull.},
month = apr,
pages = {55–59},
numpages = {5}
}

@inproceedings{10.1145/317456.317467,
author = {Moher, Thomas G.},
title = {Estimating the Distribution of Software Complexity <i>within</i> a Program},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317467},
doi = {10.1145/317456.317467},
abstract = {This paper proposes an approach to the characterization of complexity within computer software source texts. We estimate the information content of individual program tokens as the basis for a relative ordering of tokens by their 'uncertainty' or 'perculiarity' within the context of the program in which they reside. The analysis method used is in part an extension of software science methods. The information gained from the analysis highlights language usage anomalies and potential errors. This information may be useful in guiding software review activities.More theoretical work and experimental validation will be necessary before the analysis technique may be used in a productive environment.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {61–64},
numpages = {4},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317467,
author = {Moher, Thomas G.},
title = {Estimating the Distribution of Software Complexity <i>within</i> a Program},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317467},
doi = {10.1145/1165385.317467},
abstract = {This paper proposes an approach to the characterization of complexity within computer software source texts. We estimate the information content of individual program tokens as the basis for a relative ordering of tokens by their 'uncertainty' or 'perculiarity' within the context of the program in which they reside. The analysis method used is in part an extension of software science methods. The information gained from the analysis highlights language usage anomalies and potential errors. This information may be useful in guiding software review activities.More theoretical work and experimental validation will be necessary before the analysis technique may be used in a productive environment.},
journal = {SIGCHI Bull.},
month = apr,
pages = {61–64},
numpages = {4}
}

@inproceedings{10.1145/317456.317468,
author = {Brown, John Seely and Cashman, Paul M. and Malone, Thomas and Greif, Irene},
title = {Interfaces in Organizations (Panel Session): Supporting Group Work},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317468},
doi = {10.1145/317456.317468},
abstract = {Research on human factors in computer systems has emphasized supporting individuals. This panel will discuss new issues that emerge when computer systems support groups of people and whole organizations. Malone (see following paper) will suggest a broadening of the definition of user interfaces to include “organizational interfaces” and will indicate how a theoretical base for such an endeavor might be developed. Then Cashman will describe a “coordinator tool” in use at DEC for tracking the assignment of tasks to people in activities such as software maintenance. Finally, Brown will suggest how computer systems can be designed to radically increase the bandwidth of cooperation in groups by, for example, exploiting linguistic notions of context.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {65},
numpages = {1},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317468,
author = {Brown, John Seely and Cashman, Paul M. and Malone, Thomas and Greif, Irene},
title = {Interfaces in Organizations (Panel Session): Supporting Group Work},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317468},
doi = {10.1145/1165385.317468},
abstract = {Research on human factors in computer systems has emphasized supporting individuals. This panel will discuss new issues that emerge when computer systems support groups of people and whole organizations. Malone (see following paper) will suggest a broadening of the definition of user interfaces to include “organizational interfaces” and will indicate how a theoretical base for such an endeavor might be developed. Then Cashman will describe a “coordinator tool” in use at DEC for tracking the assignment of tasks to people in activities such as software maintenance. Finally, Brown will suggest how computer systems can be designed to radically increase the bandwidth of cooperation in groups by, for example, exploiting linguistic notions of context.},
journal = {SIGCHI Bull.},
month = apr,
pages = {65},
numpages = {1}
}

@inproceedings{10.1145/317456.317469,
author = {Malone, Thomas W.},
title = {Designing Organizational Interfaces},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317469},
doi = {10.1145/317456.317469},
abstract = {This paper argues that it will become increasingly important to extend our concept of user interfaces for individual users of computers to include organizational interfaces for groups of users. A number of suggestions are given for how to develop a theoretical base for designing such interfaces. For instance, examples are used to illustrate how traditional cognitive points of view can be extended to include information processing by multiple agents in organizations. Examples of design implications from other perspectives such as motivational, economic, and political are also included.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {66–71},
numpages = {6},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317469,
author = {Malone, Thomas W.},
title = {Designing Organizational Interfaces},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317469},
doi = {10.1145/1165385.317469},
abstract = {This paper argues that it will become increasingly important to extend our concept of user interfaces for individual users of computers to include organizational interfaces for groups of users. A number of suggestions are given for how to develop a theoretical base for designing such interfaces. For instance, examples are used to illustrate how traditional cognitive points of view can be extended to include information processing by multiple agents in organizations. Examples of design implications from other perspectives such as motivational, economic, and political are also included.},
journal = {SIGCHI Bull.},
month = apr,
pages = {66–71},
numpages = {6}
}

@inproceedings{10.1145/317456.317470,
author = {Landauer, T. K. and Nachbar, D. W.},
title = {Selection from Alphabetic and Numeric Menu Trees Using a Touch Screen: Breadth, Depth, and Width},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317470},
doi = {10.1145/317456.317470},
abstract = {Goal items were selected by a series of touch-menu choices among sequentially subdivided ranges of integers or alphabetically ordered words. The number of alternatives at each step, b, was varied, and, inversely, the size of the target area for the touch. Mean response time for each screen was well described by T = k+clogb, in agreement with the Hick-Hyman and Fitts' laws for decision and movement components in series. It is shown that this function favors breadth over depth in menus, whereas others might not. Speculations are offered as to when various functions could be expected.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {73–78},
numpages = {6},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317470,
author = {Landauer, T. K. and Nachbar, D. W.},
title = {Selection from Alphabetic and Numeric Menu Trees Using a Touch Screen: Breadth, Depth, and Width},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317470},
doi = {10.1145/1165385.317470},
abstract = {Goal items were selected by a series of touch-menu choices among sequentially subdivided ranges of integers or alphabetically ordered words. The number of alternatives at each step, b, was varied, and, inversely, the size of the target area for the touch. Mean response time for each screen was well described by T = k+clogb, in agreement with the Hick-Hyman and Fitts' laws for decision and movement components in series. It is shown that this function favors breadth over depth in menus, whereas others might not. Speculations are offered as to when various functions could be expected.},
journal = {SIGCHI Bull.},
month = apr,
pages = {73–78},
numpages = {6}
}

@inproceedings{10.1145/317456.317471,
author = {Tullis, Thomas S.},
title = {Designing a Menu-Based Interface to an Operating System},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317471},
doi = {10.1145/317456.317471},
abstract = {The development of a large menu-based interface to an operating system posed a number of interesting user interface questions. Among those were how to determine the user's view of the relationships among the myriad of functions in the system, and how to reflect those relationships in a menu hierarchy. An experiment utilizing a sorting technique and hierarchical cluster analysis was quite effective in learning the user's perception of the relationships among the system functions. A second experiment comparing a “broad” menu hierarchy to a “deep” menu hierarchy showed that users made significantly fewer inappropriate menu selections with the broad hierarchy.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {79–84},
numpages = {6},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317471,
author = {Tullis, Thomas S.},
title = {Designing a Menu-Based Interface to an Operating System},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317471},
doi = {10.1145/1165385.317471},
abstract = {The development of a large menu-based interface to an operating system posed a number of interesting user interface questions. Among those were how to determine the user's view of the relationships among the myriad of functions in the system, and how to reflect those relationships in a menu hierarchy. An experiment utilizing a sorting technique and hierarchical cluster analysis was quite effective in learning the user's perception of the relationships among the system functions. A second experiment comparing a “broad” menu hierarchy to a “deep” menu hierarchy showed that users made significantly fewer inappropriate menu selections with the broad hierarchy.},
journal = {SIGCHI Bull.},
month = apr,
pages = {79–84},
numpages = {6}
}

@inproceedings{10.1145/317456.317472,
author = {Butler, Keith A.},
title = {Connecting Theory and Practice: A Case Study of Achieving Usability Goals},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317472},
doi = {10.1145/317456.317472},
abstract = {This paper describes a case study of the Human Factors design, development, and testing of a computer-based financial analysis package. The project applied the “usability goals” method proposed by Bennett (1984) to structure the definition, design, and testing of the new system. Learnability was defined as a key attribute in the product concept because of its salience in users' perception of system quality. The learnability attribute was assigned an operational definition in terms of time to mastery and error avoidance/recovery. The “back-to-front” strategy of Didner &amp; Butler (1982) was applied for designing the menus. Empirical testing of user performance on sample problems in the alpha stage indicated that the new system surpassed the learnability objective. Lessons learned from this case study concern leverage in getting better managerial attention for Human Factors considerations in development projects, and clearer structure to direct needed research.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {85–88},
numpages = {4},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317472,
author = {Butler, Keith A.},
title = {Connecting Theory and Practice: A Case Study of Achieving Usability Goals},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317472},
doi = {10.1145/1165385.317472},
abstract = {This paper describes a case study of the Human Factors design, development, and testing of a computer-based financial analysis package. The project applied the “usability goals” method proposed by Bennett (1984) to structure the definition, design, and testing of the new system. Learnability was defined as a key attribute in the product concept because of its salience in users' perception of system quality. The learnability attribute was assigned an operational definition in terms of time to mastery and error avoidance/recovery. The “back-to-front” strategy of Didner &amp; Butler (1982) was applied for designing the menus. Empirical testing of user performance on sample problems in the alpha stage indicated that the new system surpassed the learnability objective. Lessons learned from this case study concern leverage in getting better managerial attention for Human Factors considerations in development projects, and clearer structure to direct needed research.},
journal = {SIGCHI Bull.},
month = apr,
pages = {85–88},
numpages = {4}
}

@inproceedings{10.1145/317456.317473,
author = {Traweek, Sharon and Lynch, Michael and Frankel, Richard and Jordon, Brigitte and Suchman, Lucy A.},
title = {Technology in Use (Panel Session)},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317473},
doi = {10.1145/317456.317473},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {89–92},
numpages = {4},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317473,
author = {Traweek, Sharon and Lynch, Michael and Frankel, Richard and Jordon, Brigitte and Suchman, Lucy A.},
title = {Technology in Use (Panel Session)},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317473},
doi = {10.1145/1165385.317473},
journal = {SIGCHI Bull.},
month = apr,
pages = {89–92},
numpages = {4}
}

@inproceedings{10.1145/317456.317474,
author = {Good, Michael},
title = {The Use of Logging Data in the Design of a New Text Editor},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317474},
doi = {10.1145/317456.317474},
abstract = {Many different human factors techniques are available to the designer of a new computer system. This case study examines how one technique, the use of logging data, was used throughout the design of a new text editor which is measurably easy to learn and easy to use. Logging data was used in four areas: keyboard design, the initial design of the editor's command set, refinements made later in the design cycle, and the construction of a system performance benchmark.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {93–97},
numpages = {5},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317474,
author = {Good, Michael},
title = {The Use of Logging Data in the Design of a New Text Editor},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317474},
doi = {10.1145/1165385.317474},
abstract = {Many different human factors techniques are available to the designer of a new computer system. This case study examines how one technique, the use of logging data, was used throughout the design of a new text editor which is measurably easy to learn and easy to use. Logging data was used in four areas: keyboard design, the initial design of the editor's command set, refinements made later in the design cycle, and the construction of a system performance benchmark.},
journal = {SIGCHI Bull.},
month = apr,
pages = {93–97},
numpages = {5}
}

@inproceedings{10.1145/317456.317475,
author = {Borenstein, Nathaniel S.},
title = {The Evaluation of Text Editors: A Critical Review of the Roberts and Morgan Methodology Based on New Experiments},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317475},
doi = {10.1145/317456.317475},
abstract = {Three text editors were studied using the editor evaluation methodology developed by Roberts and Moran [3, 4]. The results are presented as an extension of the studies by Roberts and Moran, with comparisons to the editors they studied earlier. In addition, supplementary measurements were taken that suggest minor flaws in the Roberts and Moran methodology. Further problems with the methodology are discussed, with an eye toward improving the methodology for future use. Although three significant problems with the methodology are reported, the problems are interesting primarily as lessons for the design of future evaluation methodologies. The Roberts and Moran methodology remains largely useful for the purposes for which it was designed.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {99–105},
numpages = {7},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317475,
author = {Borenstein, Nathaniel S.},
title = {The Evaluation of Text Editors: A Critical Review of the Roberts and Morgan Methodology Based on New Experiments},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317475},
doi = {10.1145/1165385.317475},
abstract = {Three text editors were studied using the editor evaluation methodology developed by Roberts and Moran [3, 4]. The results are presented as an extension of the studies by Roberts and Moran, with comparisons to the editors they studied earlier. In addition, supplementary measurements were taken that suggest minor flaws in the Roberts and Moran methodology. Further problems with the methodology are discussed, with an eye toward improving the methodology for future use. Although three significant problems with the methodology are reported, the problems are interesting primarily as lessons for the design of future evaluation methodologies. The Roberts and Moran methodology remains largely useful for the purposes for which it was designed.},
journal = {SIGCHI Bull.},
month = apr,
pages = {99–105},
numpages = {7}
}

@inproceedings{10.1145/317456.317476,
author = {Lund, Michelle A.},
title = {Evaluating the User Interface: The Candid Camera Approach},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317476},
doi = {10.1145/317456.317476},
abstract = {In the development of a new interactive graphics application, considerable effort was spent on designing a user interface which would be easy to use. When a portion of the application was completed, typical potential users were brought in to help evaluate the interface. They were given a sample task and a short introduction to the application; then their efforts to complete the task were observed and videotaped.This method of evaluating the user interface provided the development staff with quite a bit of valuable information. Changes were made, and more testing was done, including using some subjects for a second time.This paper describes how this evaluation method was used for two purposes: to point out problem areas in the interface, and to verify that changes made have improved the user interface.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {107–113},
numpages = {7},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317476,
author = {Lund, Michelle A.},
title = {Evaluating the User Interface: The Candid Camera Approach},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317476},
doi = {10.1145/1165385.317476},
abstract = {In the development of a new interactive graphics application, considerable effort was spent on designing a user interface which would be easy to use. When a portion of the application was completed, typical potential users were brought in to help evaluate the interface. They were given a sample task and a short introduction to the application; then their efforts to complete the task were observed and videotaped.This method of evaluating the user interface provided the development staff with quite a bit of valuable information. Changes were made, and more testing was done, including using some subjects for a second time.This paper describes how this evaluation method was used for two purposes: to point out problem areas in the interface, and to verify that changes made have improved the user interface.},
journal = {SIGCHI Bull.},
month = apr,
pages = {107–113},
numpages = {7}
}

@inproceedings{10.1145/317456.317477,
author = {Bly, Sara A. and Frysinger, Steven P. and Lunney, David and Mansur, Douglass L. and Mezrich, Joseph J. and Morrison, Robert C. and Buxton, William},
title = {Communicating with Sound (Panel Session},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317477},
doi = {10.1145/317456.317477},
abstract = {The Communicating with Sound panel for CHI '85 will focus on ways of expanding the user interface by using sound as a significant means of output. As a user's communication from the computer has progressed from large (and often smeary) printout to a teletypewriter and, finally, to the multi-window workstation displays of today, the emphasis has remained primarily on visual output. Although many user terminals and workstations have the capability of generating sound, that capability is rarely used for more than audio cues (indicating status such as an error condition or task completion) and simple musical tunes. Research shows that sounds convey meaningful information to users. With examples of such research, the panel members will demonstrate a variety of uses of sound output, discuss issues raised by the work, and suggest further directions. The intent of the panel is to stimulate thinking about expanding the user interface and to discuss areas for future research.In the statements that follow, each panelist will describe his or her own work, including the data and audio dimensions used, the value of the research, remaining issues to be addressed, and suggestions for future research and application. A list of references is included for those who wish further reading.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {115–119},
numpages = {5},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317477,
author = {Bly, Sara A. and Frysinger, Steven P. and Lunney, David and Mansur, Douglass L. and Mezrich, Joseph J. and Morrison, Robert C. and Buxton, William},
title = {Communicating with Sound (Panel Session},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317477},
doi = {10.1145/1165385.317477},
abstract = {The Communicating with Sound panel for CHI '85 will focus on ways of expanding the user interface by using sound as a significant means of output. As a user's communication from the computer has progressed from large (and often smeary) printout to a teletypewriter and, finally, to the multi-window workstation displays of today, the emphasis has remained primarily on visual output. Although many user terminals and workstations have the capability of generating sound, that capability is rarely used for more than audio cues (indicating status such as an error condition or task completion) and simple musical tunes. Research shows that sounds convey meaningful information to users. With examples of such research, the panel members will demonstrate a variety of uses of sound output, discuss issues raised by the work, and suggest further directions. The intent of the panel is to stimulate thinking about expanding the user interface and to discuss areas for future research.In the statements that follow, each panelist will describe his or her own work, including the data and audio dimensions used, the value of the research, remaining issues to be addressed, and suggestions for future research and application. A list of references is included for those who wish further reading.},
journal = {SIGCHI Bull.},
month = apr,
pages = {115–119},
numpages = {5}
}

@inproceedings{10.1145/317456.317478,
author = {Grudin, Jonathan and Barnard, Phil},
title = {When Does an Abbreviation Become a Word? And Related Questions},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317478},
doi = {10.1145/317456.317478},
abstract = {An experiment is reported in which subjects previously naive to text editing learned to use a set of editing commands. Some subjects used abbreviations from the beginning. Others began by using full command names, then switched to the (optional) use of abbreviations, either of their own devising or of our selection. We found significant differences in the number and nature of the errors produced by subjects in the different conditions. People who created their own abbreviations did most poorly, and did not appear to learn from this experience. Those who used abbreviations from the start were more likely to fall into error through misrecalling the referent names. The results suggest aspects of the underlying cognitive representations, with implications for the design of software interfaces.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {121–125},
numpages = {5},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317478,
author = {Grudin, Jonathan and Barnard, Phil},
title = {When Does an Abbreviation Become a Word? And Related Questions},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317478},
doi = {10.1145/1165385.317478},
abstract = {An experiment is reported in which subjects previously naive to text editing learned to use a set of editing commands. Some subjects used abbreviations from the beginning. Others began by using full command names, then switched to the (optional) use of abbreviations, either of their own devising or of our selection. We found significant differences in the number and nature of the errors produced by subjects in the different conditions. People who created their own abbreviations did most poorly, and did not appear to learn from this experience. Those who used abbreviations from the start were more likely to fall into error through misrecalling the referent names. The results suggest aspects of the underlying cognitive representations, with implications for the design of software interfaces.},
journal = {SIGCHI Bull.},
month = apr,
pages = {121–125},
numpages = {5}
}

@inproceedings{10.1145/317456.317479,
author = {Dumais, Susan T. and Jones, William P.},
title = {A Comparison of Symbolic and Spatial Filing},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317479},
doi = {10.1145/317456.317479},
abstract = {The traditional and still dominant form of object reference in computing systems is symbolic - data files, programs, etc. are initially labeled and subsequently referred to by name. This approach is being supplemented on some systems by a spatial alternative which is often driven by an office or desktop metaphor (e.g. Apple's Lisa and MacIntosh systems, or Bolt's 1979 Spatial Data Management System). In such systems, an object is placed in a simulated two- or three-dimensional space, and can later be retrieved by pointing to its location. In order to begin to understand the relative merits of spatial and symbolic filing schemes for representing and organizing information, we compared four ways of filing computer objects. We found location information to be of limited utility, either by itself or in combination with symbolic information. This calls into question the generality and efficacy of the desktop metaphor for information retrieval.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {127–130},
numpages = {4},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317479,
author = {Dumais, Susan T. and Jones, William P.},
title = {A Comparison of Symbolic and Spatial Filing},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317479},
doi = {10.1145/1165385.317479},
abstract = {The traditional and still dominant form of object reference in computing systems is symbolic - data files, programs, etc. are initially labeled and subsequently referred to by name. This approach is being supplemented on some systems by a spatial alternative which is often driven by an office or desktop metaphor (e.g. Apple's Lisa and MacIntosh systems, or Bolt's 1979 Spatial Data Management System). In such systems, an object is placed in a simulated two- or three-dimensional space, and can later be retrieved by pointing to its location. In order to begin to understand the relative merits of spatial and symbolic filing schemes for representing and organizing information, we compared four ways of filing computer objects. We found location information to be of limited utility, either by itself or in combination with symbolic information. This calls into question the generality and efficacy of the desktop metaphor for information retrieval.},
journal = {SIGCHI Bull.},
month = apr,
pages = {127–130},
numpages = {4}
}

@inproceedings{10.1145/317456.317480,
author = {Furnas, George W.},
title = {Experience with an Adaptive Indexing Scheme},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317480},
doi = {10.1145/317456.317480},
abstract = {Previous work has shown that there is a major vocabulary barrier for new or intermittent users of computer systems. The barrier can be substantially lowered with a rich, empirically defined, frequency weighted index. This paper discusses experience with an adaptive technique for constructing such an index. In addition to being an easy way for system designers to collect the necessary data, an adaptive system has the additional advantage that data is collected from real users in real situations, not in some laboratory approximation. Implementation considerations, preliminary results and future theoretical directions are discussed.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {131–135},
numpages = {5},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317480,
author = {Furnas, George W.},
title = {Experience with an Adaptive Indexing Scheme},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317480},
doi = {10.1145/1165385.317480},
abstract = {Previous work has shown that there is a major vocabulary barrier for new or intermittent users of computer systems. The barrier can be substantially lowered with a rich, empirically defined, frequency weighted index. This paper discusses experience with an adaptive technique for constructing such an index. In addition to being an easy way for system designers to collect the necessary data, an adaptive system has the additional advantage that data is collected from real users in real situations, not in some laboratory approximation. Implementation considerations, preliminary results and future theoretical directions are discussed.},
journal = {SIGCHI Bull.},
month = apr,
pages = {131–135},
numpages = {5}
}

@inproceedings{10.1145/317456.317481,
author = {Moran, Thomas and Olson, Judith Reitman and Wixon, Dennis and Whiteside, John and Mack, Robert},
title = {Computer Human Factors in Computer Interface Design (Panel Session)},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317481},
doi = {10.1145/317456.317481},
abstract = {Human factors psychologists contribute in many ways to improving human-computer interaction. One contribution involves evaluating existing or prototype systems, in order to assess usability and identify problems. Another involves contributing more directly to the design of systems in the first place: that is, not only evaluating systems but bringing to bear empirical methods and theoretical considerations that help specify what are plausible designs in the first place. The goal of this panel is to discuss four case studies emphasizing this role of cognitive human factors, and identify relevant methods and theoretical considerations.The panelists will present examples of prototypes or products to whose design they contributed, with the aim of characterizing the problem (or problems) they tried to solve, the approach to identifying a design solution for that problem, and evidence that the approach was useful.Robert Mack will discuss an editor prototype designed to get novices started doing meaningful work quickly and helping them to continue acquiring new skills, with virtually no explicit instruction. The prototype is being designed in large part by identifying key novice problems and expectations, and trying to design the interface to better accommodate these expectations. The first goal of getting novices started relatively quickly has been achieved but problems remain as novices try to acquire further text-editing skill. These problems — and solutions to them — are being identified through a process of iterative design and evaluation.Dennis Wixon will discuss implications for designing usable interfaces of the User-Derived-Interface project (Good, M., Whiteside, J., Wixon, D. and Jones, S., 1984). The project involved a simulation of a restricted natural language interface for an electronic mail system. The design process was driven by the behavioral goal of getting users started relatively quickly with little or no instruction or interface aids. Actual user interaction with the simulation coupled with iterative design and evaluation provided interface specifications. This prototype illustrates a number of techniques for bringing usability into the software engineering process.These presentations will discuss the role of empirical methods such as verbal protocol techniques for identifying user problems with existing computer systems (e.g., Lewis, 1982; Mack, Lewis &amp; Carroll, 1983; Douglas &amp; Moran, 1983), including variations aimed at identifying user expectations that may be able to guide design (e.g., Mack, 1984); interface simulations for studying user interactions again with the aim of letting user behavior guide interface design (e.g., Kelley, 1984; Good, Whiteside, Wixon &amp; Jones, 1984), and iterative design and evaluation of interfaces, aimed at achieving behavioral goals (e.g., Carroll &amp; Rosson, 1984; Gould &amp; Lewis, 1983).},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {137–138},
numpages = {2},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317481,
author = {Moran, Thomas and Olson, Judith Reitman and Wixon, Dennis and Whiteside, John and Mack, Robert},
title = {Computer Human Factors in Computer Interface Design (Panel Session)},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317481},
doi = {10.1145/1165385.317481},
abstract = {Human factors psychologists contribute in many ways to improving human-computer interaction. One contribution involves evaluating existing or prototype systems, in order to assess usability and identify problems. Another involves contributing more directly to the design of systems in the first place: that is, not only evaluating systems but bringing to bear empirical methods and theoretical considerations that help specify what are plausible designs in the first place. The goal of this panel is to discuss four case studies emphasizing this role of cognitive human factors, and identify relevant methods and theoretical considerations.The panelists will present examples of prototypes or products to whose design they contributed, with the aim of characterizing the problem (or problems) they tried to solve, the approach to identifying a design solution for that problem, and evidence that the approach was useful.Robert Mack will discuss an editor prototype designed to get novices started doing meaningful work quickly and helping them to continue acquiring new skills, with virtually no explicit instruction. The prototype is being designed in large part by identifying key novice problems and expectations, and trying to design the interface to better accommodate these expectations. The first goal of getting novices started relatively quickly has been achieved but problems remain as novices try to acquire further text-editing skill. These problems — and solutions to them — are being identified through a process of iterative design and evaluation.Dennis Wixon will discuss implications for designing usable interfaces of the User-Derived-Interface project (Good, M., Whiteside, J., Wixon, D. and Jones, S., 1984). The project involved a simulation of a restricted natural language interface for an electronic mail system. The design process was driven by the behavioral goal of getting users started relatively quickly with little or no instruction or interface aids. Actual user interaction with the simulation coupled with iterative design and evaluation provided interface specifications. This prototype illustrates a number of techniques for bringing usability into the software engineering process.These presentations will discuss the role of empirical methods such as verbal protocol techniques for identifying user problems with existing computer systems (e.g., Lewis, 1982; Mack, Lewis &amp; Carroll, 1983; Douglas &amp; Moran, 1983), including variations aimed at identifying user expectations that may be able to guide design (e.g., Mack, 1984); interface simulations for studying user interactions again with the aim of letting user behavior guide interface design (e.g., Kelley, 1984; Good, Whiteside, Wixon &amp; Jones, 1984), and iterative design and evaluation of interfaces, aimed at achieving behavioral goals (e.g., Carroll &amp; Rosson, 1984; Gould &amp; Lewis, 1983).},
journal = {SIGCHI Bull.},
month = apr,
pages = {137–138},
numpages = {2}
}

@inproceedings{10.1145/317456.317482,
author = {Mack, Robert},
title = {Identifying and Designing toward New User Expectations in a Prototype Text-Editor (Panel Session)},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317482},
doi = {10.1145/317456.317482},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {139–141},
numpages = {3},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317482,
author = {Mack, Robert},
title = {Identifying and Designing toward New User Expectations in a Prototype Text-Editor (Panel Session)},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317482},
doi = {10.1145/1165385.317482},
journal = {SIGCHI Bull.},
month = apr,
pages = {139–141},
numpages = {3}
}

@inproceedings{10.1145/317456.317483,
author = {Olson, Judith Reitman},
title = {Expanded Design Procedures for Learnable, Usable Interfaces (Panel Session)},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317483},
doi = {10.1145/317456.317483},
abstract = {Designers of interactive computer systems have begun to incorporate a number of good techniques in the design process to insure that the system will be easy to learn and easy to use. Though not all design projects use all the steps recommended, the steps are well known:Define the tasks the user has to perform,Know the capabilities of the user,Gather relevant hardware/software constraints,From guidelines, design a first prototype,Test the prototype with users,Iterate changes in the design and repeat the tests until the deadline is reached.In our experience designing a new interface, steps 1 and 4 were the ones that were the most difficult and step 5 was the one that took extra time to plan well. We had difficulty defining what would go into a new task, and from broad guidelines, we had to develop one specific implementation for our tasks. Furthermore, so that in each test we would learn something of value for future designs, we knew that we wanted to test pairs of prototypes that differed in only one feature. Choosing which single feature to alter in each pair required careful planning. In what follows, I describe each of these difficulties more fully and show how we approached each in our environment.Normally, a task is defined as a computer-based analog of an existing task, such as wordprocessing being the computer-based analog of typing. Since we had to build an interface for an entirely new task, we had to invent how the user would think about the task. We had to invent the objects on which the user would operate and then the actions that would be performed on those objects. We had to specify the mental representation in the absence of previous similar tasks.In our case, we were designing the interface for a communications manager to designate the path to be taken for routing 800-calls to their final destination as a function of time of day, day of week, holidays, percentage distribution, etc. From the large set of known formal representations of data, e.g. lists, pictures, tables, hierarchies, and networks, we found three that seemed to capture the information sufficient for our task. We found that a hierarchy (tree structure), a restricted programming language in which there were only IF-THEN-ELSEs and definitions, and a long form to be filled out with all possible ordered combinations of the desired features, were all sufficient representations. We then asked potential users in casual interviews which format they found easiest to understand. It was immediately clear even from a relatively small number of subjects that the tree representation was preferred.The second aspect of defining the task involved specifying what actions the user would take on this representation. Since in all interfaces, users have to move about, select an item to work on, enter information, delete information, and change modes (from data entry to command, typically), we looked for these kinds of actions in our task. The actions immediately fell into place, with commands being generated for moving about a tree, entering nodes and branches, etc.After gathering information on who the end users were and what hardware constraints we had, we designed our first prototype. This was our next most involved chore. Our broad guidelines said that we should:
Present information on the computer in a representation as close as possible to the user's mental representation.Minimize the long-term and short-term memory loads (e.g. make retrieval of commands and codes easy, give the user clues about where he or she is in a complicated procedure or data structure).Construct a dialog that holds to natural conversational conventions (e.g., make pauses predictable, acknowledge long delays, use English imperative structure in the command syntax).Our initial design on paper was fairly easy to construct. We followed that, however, with an important analysis step before we built our first prototype. For each part of the design, we constructed an alternative design that seemed to fit within the same constraints and within the guidelines. That is, we identified the essential components of our interface: the representation of the data, the organization of the command sector, the reminders, and the specific command implementations such as how to move around the data representation. For example, in the command sector there are alternative ways to arrange the commands for display: they could be grouped by similar function so that all “move” commands were clustered and all “entry” commands were clustered, etc, or they could be grouped into common sequences, such as those that people naturally follow in initially entering the nodes and branches of the tree structures. Once each component had an alternative, we debated the merits of each. Our first prototype, then, was the result of this first paper design plus the alterations that were generated by this analysis procedure.The next step entailed testing our design with real users. Since we wanted to test our prototypes so that we learned something useful for our next assignment, we chose to test two prototypes at a time. If we were to learn something from the test, then only one component could differ between the two prototypes. The difficulty arose in deciding which component was to be tested in each pair. For this task, we went back to our initial component-by-component debate about the prototype. For each of the components and its alternative, we scored the choice on three dimensions:That is, first, for some alternatives, the better choice was predictable. For example, displaying command names was known to be more helpful than not displaying them. Testing this alternative would not teach us very much. Second, we needed to choose some alternatives early, so that the developers could begin immediately with some preliminary work. For example, our developers needed to know early whether the data would be displayed as a form or a tree so they could set up appropriate data structures. And third, some alternatives would appear again in future design projects. For example, all projects require some way of moving about the data but few deal directly with trees. Knowledge gained now about the movement function would pay off in the future whereas how to display trees may not.Once we prioritized our alternatives on these dimensions, we were able to choose the alternative for the first prototype test. After the test, we found other ideas to incorporate in the next iteration, but went through the same analysis procedure, listing the components, debating alternatives, and prioritizing those to be tested in the next iteration.In summary, the procedure we followed in designing and testing our prototypes was standard in overall form, flowing from defining the task, user, and constraints; building prototypes; and testing them with users. We differed, however, in three of our steps. We spent important initial time considering the best task representation to display to the user. We analyzed the individual components of our first prototype, generating a design for actual implementation that was more defensibly good than our first paper design.And, in our iterative testing procedure, we selected pairs of prototypes for test, the pairs differing on only one component of the design. The component for testing was selected according to whether the test would teach us something, whether it was important to decide early in the development process, and whether the component would appear again in designs we encountered in the future. These expanded steps in the design process not only added to our confidence that our early design was reasonably good, but also gave us the data and theory with which to convince others, notably developers and project managers, of the merit of our design. And, the process taught us something of use for our next design project.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {142–143},
numpages = {2},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317483,
author = {Olson, Judith Reitman},
title = {Expanded Design Procedures for Learnable, Usable Interfaces (Panel Session)},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317483},
doi = {10.1145/1165385.317483},
abstract = {Designers of interactive computer systems have begun to incorporate a number of good techniques in the design process to insure that the system will be easy to learn and easy to use. Though not all design projects use all the steps recommended, the steps are well known:Define the tasks the user has to perform,Know the capabilities of the user,Gather relevant hardware/software constraints,From guidelines, design a first prototype,Test the prototype with users,Iterate changes in the design and repeat the tests until the deadline is reached.In our experience designing a new interface, steps 1 and 4 were the ones that were the most difficult and step 5 was the one that took extra time to plan well. We had difficulty defining what would go into a new task, and from broad guidelines, we had to develop one specific implementation for our tasks. Furthermore, so that in each test we would learn something of value for future designs, we knew that we wanted to test pairs of prototypes that differed in only one feature. Choosing which single feature to alter in each pair required careful planning. In what follows, I describe each of these difficulties more fully and show how we approached each in our environment.Normally, a task is defined as a computer-based analog of an existing task, such as wordprocessing being the computer-based analog of typing. Since we had to build an interface for an entirely new task, we had to invent how the user would think about the task. We had to invent the objects on which the user would operate and then the actions that would be performed on those objects. We had to specify the mental representation in the absence of previous similar tasks.In our case, we were designing the interface for a communications manager to designate the path to be taken for routing 800-calls to their final destination as a function of time of day, day of week, holidays, percentage distribution, etc. From the large set of known formal representations of data, e.g. lists, pictures, tables, hierarchies, and networks, we found three that seemed to capture the information sufficient for our task. We found that a hierarchy (tree structure), a restricted programming language in which there were only IF-THEN-ELSEs and definitions, and a long form to be filled out with all possible ordered combinations of the desired features, were all sufficient representations. We then asked potential users in casual interviews which format they found easiest to understand. It was immediately clear even from a relatively small number of subjects that the tree representation was preferred.The second aspect of defining the task involved specifying what actions the user would take on this representation. Since in all interfaces, users have to move about, select an item to work on, enter information, delete information, and change modes (from data entry to command, typically), we looked for these kinds of actions in our task. The actions immediately fell into place, with commands being generated for moving about a tree, entering nodes and branches, etc.After gathering information on who the end users were and what hardware constraints we had, we designed our first prototype. This was our next most involved chore. Our broad guidelines said that we should:
Present information on the computer in a representation as close as possible to the user's mental representation.Minimize the long-term and short-term memory loads (e.g. make retrieval of commands and codes easy, give the user clues about where he or she is in a complicated procedure or data structure).Construct a dialog that holds to natural conversational conventions (e.g., make pauses predictable, acknowledge long delays, use English imperative structure in the command syntax).Our initial design on paper was fairly easy to construct. We followed that, however, with an important analysis step before we built our first prototype. For each part of the design, we constructed an alternative design that seemed to fit within the same constraints and within the guidelines. That is, we identified the essential components of our interface: the representation of the data, the organization of the command sector, the reminders, and the specific command implementations such as how to move around the data representation. For example, in the command sector there are alternative ways to arrange the commands for display: they could be grouped by similar function so that all “move” commands were clustered and all “entry” commands were clustered, etc, or they could be grouped into common sequences, such as those that people naturally follow in initially entering the nodes and branches of the tree structures. Once each component had an alternative, we debated the merits of each. Our first prototype, then, was the result of this first paper design plus the alterations that were generated by this analysis procedure.The next step entailed testing our design with real users. Since we wanted to test our prototypes so that we learned something useful for our next assignment, we chose to test two prototypes at a time. If we were to learn something from the test, then only one component could differ between the two prototypes. The difficulty arose in deciding which component was to be tested in each pair. For this task, we went back to our initial component-by-component debate about the prototype. For each of the components and its alternative, we scored the choice on three dimensions:That is, first, for some alternatives, the better choice was predictable. For example, displaying command names was known to be more helpful than not displaying them. Testing this alternative would not teach us very much. Second, we needed to choose some alternatives early, so that the developers could begin immediately with some preliminary work. For example, our developers needed to know early whether the data would be displayed as a form or a tree so they could set up appropriate data structures. And third, some alternatives would appear again in future design projects. For example, all projects require some way of moving about the data but few deal directly with trees. Knowledge gained now about the movement function would pay off in the future whereas how to display trees may not.Once we prioritized our alternatives on these dimensions, we were able to choose the alternative for the first prototype test. After the test, we found other ideas to incorporate in the next iteration, but went through the same analysis procedure, listing the components, debating alternatives, and prioritizing those to be tested in the next iteration.In summary, the procedure we followed in designing and testing our prototypes was standard in overall form, flowing from defining the task, user, and constraints; building prototypes; and testing them with users. We differed, however, in three of our steps. We spent important initial time considering the best task representation to display to the user. We analyzed the individual components of our first prototype, generating a design for actual implementation that was more defensibly good than our first paper design.And, in our iterative testing procedure, we selected pairs of prototypes for test, the pairs differing on only one component of the design. The component for testing was selected according to whether the test would teach us something, whether it was important to decide early in the development process, and whether the component would appear again in designs we encountered in the future. These expanded steps in the design process not only added to our confidence that our early design was reasonably good, but also gave us the data and theory with which to convince others, notably developers and project managers, of the merit of our design. And, the process taught us something of use for our next design project.},
journal = {SIGCHI Bull.},
month = apr,
pages = {142–143},
numpages = {2}
}

@inproceedings{10.1145/317456.317484,
author = {Wixon, Dennis and Whiteside, John},
title = {Engineering for Usability (Panel Session): Lessons from the User Derived Interface},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317484},
doi = {10.1145/317456.317484},
abstract = {The focus here is on the lessons learned from the UDI project for building usability into the software development process. In the UDI project we attempted to engineer a usable system. That process involved:defining an appropriate metric for measuring usability,setting explicit levels of usability to be achieveddetermining an appropriate methodology for building usability into the system,delivering a seemingly functional system with an easily changed interface very early in the development cycle, andrecognizing the tentative nature of the initial design.Using the UDI project as an example, each of the above principles will be discussed in detail.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {144–147},
numpages = {4},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317484,
author = {Wixon, Dennis and Whiteside, John},
title = {Engineering for Usability (Panel Session): Lessons from the User Derived Interface},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317484},
doi = {10.1145/1165385.317484},
abstract = {The focus here is on the lessons learned from the UDI project for building usability into the software development process. In the UDI project we attempted to engineer a usable system. That process involved:defining an appropriate metric for measuring usability,setting explicit levels of usability to be achieveddetermining an appropriate methodology for building usability into the system,delivering a seemingly functional system with an easily changed interface very early in the development cycle, andrecognizing the tentative nature of the initial design.Using the UDI project as an example, each of the above principles will be discussed in detail.},
journal = {SIGCHI Bull.},
month = apr,
pages = {144–147},
numpages = {4}
}

@inproceedings{10.1145/317456.317485,
author = {Carroll, John M. and Kay, Dana S.},
title = {Prompting, Feedback and Error Correction in the Design of a Scenario Machine},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317485},
doi = {10.1145/317456.317485},
abstract = {The recent technical literature abounds with a variety of studies documenting and analyzing the problems people encounter in learning to use contemporary computer equipment. This has been a major focus of the recent work in our laboratory ([6], [9]). The project such work must entrain is the development of design approaches to these problems. We have been and are developing alternate designs for training manuals and for in-system training ([2], [4], [5], [7]).This paper is a report of work in progress in this area. We describe a design approach to in-system training referred to as the Scenario Machine, and describe some initial results from an empirical learning study of four scenario machines.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {149–153},
numpages = {5},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317485,
author = {Carroll, John M. and Kay, Dana S.},
title = {Prompting, Feedback and Error Correction in the Design of a Scenario Machine},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317485},
doi = {10.1145/1165385.317485},
abstract = {The recent technical literature abounds with a variety of studies documenting and analyzing the problems people encounter in learning to use contemporary computer equipment. This has been a major focus of the recent work in our laboratory ([6], [9]). The project such work must entrain is the development of design approaches to these problems. We have been and are developing alternate designs for training manuals and for in-system training ([2], [4], [5], [7]).This paper is a report of work in progress in this area. We describe a design approach to in-system training referred to as the Scenario Machine, and describe some initial results from an empirical learning study of four scenario machines.},
journal = {SIGCHI Bull.},
month = apr,
pages = {149–153},
numpages = {5}
}

@inproceedings{10.1145/317456.317486,
author = {Pollack, Martha E.},
title = {Information Sought and Information Provided: An Empirical Study of User/Expert Dialogues},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317486},
doi = {10.1145/317456.317486},
abstract = {Transcripts of computer-mail users seeking advice from an expert were studied to investigate the complementary claims that people often do not know what information they need to obtain in order to achieve their goals, and consequently, that experts must identify inappropriate queries and infer and respond to the goals behind them. This paper reports on one facet of the transcript analysis, namely, the identification of the types of relation that hold between the action that an advice-seeker asks about and the action that an expert tells him how to perform. Three such relations between actions are identified: generates, enables, and is-alternative-to. The claim is made that a cooperative advice-providing system, such as a help system or an expert system, must be able to compute these relations between actions.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {155–159},
numpages = {5},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317486,
author = {Pollack, Martha E.},
title = {Information Sought and Information Provided: An Empirical Study of User/Expert Dialogues},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317486},
doi = {10.1145/1165385.317486},
abstract = {Transcripts of computer-mail users seeking advice from an expert were studied to investigate the complementary claims that people often do not know what information they need to obtain in order to achieve their goals, and consequently, that experts must identify inappropriate queries and infer and respond to the goals behind them. This paper reports on one facet of the transcript analysis, namely, the identification of the types of relation that hold between the action that an advice-seeker asks about and the action that an expert tells him how to perform. Three such relations between actions are identified: generates, enables, and is-alternative-to. The claim is made that a cooperative advice-providing system, such as a help system or an expert system, must be able to compute these relations between actions.},
journal = {SIGCHI Bull.},
month = apr,
pages = {155–159},
numpages = {5}
}

@inproceedings{10.1145/317456.317487,
author = {Fischer, Gerhard and Lemke, Andreas and Schwab, Thomas},
title = {Knowledge-Based Help Systems},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317487},
doi = {10.1145/317456.317487},
abstract = {Our research goals are to understand the nature of, construct and evaluate intelligent interfaces as knowledge-based systems. In this paper we demonstrate the need for help systems as an essential part of human-computer communication. Help strategies are based on a model of the task (to understand what the user is doing or which goals he/she1 wants to achieve) and a model of the user (to guarantee that these systems are non-intrusive and that they pay attention to the needs of individual users).We illustrate that passive and active help systems have to be constructed as knowledge-based systems. Two operational systems (PASSIVIST and ACTIVIST) are described to show the usefulness of this approach.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {161–167},
numpages = {7},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317487,
author = {Fischer, Gerhard and Lemke, Andreas and Schwab, Thomas},
title = {Knowledge-Based Help Systems},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317487},
doi = {10.1145/1165385.317487},
abstract = {Our research goals are to understand the nature of, construct and evaluate intelligent interfaces as knowledge-based systems. In this paper we demonstrate the need for help systems as an essential part of human-computer communication. Help strategies are based on a model of the task (to understand what the user is doing or which goals he/she1 wants to achieve) and a model of the user (to guarantee that these systems are non-intrusive and that they pay attention to the needs of individual users).We illustrate that passive and active help systems have to be constructed as knowledge-based systems. Two operational systems (PASSIVIST and ACTIVIST) are described to show the usefulness of this approach.},
journal = {SIGCHI Bull.},
month = apr,
pages = {161–167},
numpages = {7}
}

@inproceedings{10.1145/317456.317488,
author = {Hayes, Philip J. and Szekely, Pedro A. and Lerner, Richard A.},
title = {Design Alternatives for User Interface Management Sytems Based on Experience with COUSIN},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317488},
doi = {10.1145/317456.317488},
abstract = {User interface management systems (UIMSs) provide user interfaces to application systems based on an abstract definition of the interface required. This approach can provide higher-quality interfaces at a lower construction cost. In this paper we consider three design choices for UIMSs which critically affect the quality of the user interfaces built with a UIMS, and the cost of constructing the interfaces. The choices are examined in terms of a general model of a UIMS. They concern the sharing of control between the UIMS and the applications it provides interfaces to, the level of abstraction in the definition of the information exchanged between user and application, and the level of abstraction in the definition of the sequencing of the dialogue. For each choice, we argue for a specific alternative. We go on to present COUSIN, a UIMS that provides graphical interfaces for a variety of applications based on highly abstracted interface definitions. COUSIN'S design corresponds to the alternatives we argued for in two out of three cases, and partially satisfies the third. An interface developed through, and run by COUSIN is described in some detail.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {169–175},
numpages = {7},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317488,
author = {Hayes, Philip J. and Szekely, Pedro A. and Lerner, Richard A.},
title = {Design Alternatives for User Interface Management Sytems Based on Experience with COUSIN},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317488},
doi = {10.1145/1165385.317488},
abstract = {User interface management systems (UIMSs) provide user interfaces to application systems based on an abstract definition of the interface required. This approach can provide higher-quality interfaces at a lower construction cost. In this paper we consider three design choices for UIMSs which critically affect the quality of the user interfaces built with a UIMS, and the cost of constructing the interfaces. The choices are examined in terms of a general model of a UIMS. They concern the sharing of control between the UIMS and the applications it provides interfaces to, the level of abstraction in the definition of the information exchanged between user and application, and the level of abstraction in the definition of the sequencing of the dialogue. For each choice, we argue for a specific alternative. We go on to present COUSIN, a UIMS that provides graphical interfaces for a variety of applications based on highly abstracted interface definitions. COUSIN'S design corresponds to the alternatives we argued for in two out of three cases, and partially satisfies the third. An interface developed through, and run by COUSIN is described in some detail.},
journal = {SIGCHI Bull.},
month = apr,
pages = {169–175},
numpages = {7}
}

@inproceedings{10.1145/317456.317489,
author = {Schulert, Andrew J. and Rogers, George T. and Hamilton, James A.},
title = {ADM — a Dialog Manager},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317489},
doi = {10.1145/317456.317489},
abstract = {ADM is a system for developing user interfaces. We call it a dialog manager; it is similar to what others call a “User Interface Management System” [8]. Although ADM is still being developed, it has been used to construct several applications.A dialog manager divides an application into an “interaction handler,” which interacts with the user, and an “underlying application,” which processes user commands and data. With ADM the application designer writes the underlying application in a conventional programming language and defines the interface between interaction handler and underlying application in terms of “tasks,” things the user can do, and “states,” sets of tasks that are active at one time. The user interface designer defines the interaction handler in terms of “presentation techniques,” which present tasks to the user, and “structuring techniques,” which describe screen layout. Design decisions made for ADM include using a precompiled, declarative dialog description, a flexible division between interaction handler and underlying application, allowing either interaction handler or underlying application to maintain control, and the inclusion of help and error support.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {177–183},
numpages = {7},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317489,
author = {Schulert, Andrew J. and Rogers, George T. and Hamilton, James A.},
title = {ADM — a Dialog Manager},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317489},
doi = {10.1145/1165385.317489},
abstract = {ADM is a system for developing user interfaces. We call it a dialog manager; it is similar to what others call a “User Interface Management System” [8]. Although ADM is still being developed, it has been used to construct several applications.A dialog manager divides an application into an “interaction handler,” which interacts with the user, and an “underlying application,” which processes user commands and data. With ADM the application designer writes the underlying application in a conventional programming language and defines the interface between interaction handler and underlying application in terms of “tasks,” things the user can do, and “states,” sets of tasks that are active at one time. The user interface designer defines the interaction handler in terms of “presentation techniques,” which present tasks to the user, and “structuring techniques,” which describe screen layout. Design decisions made for ADM include using a precompiled, declarative dialog description, a flexible division between interaction handler and underlying application, allowing either interaction handler or underlying application to maintain control, and the inclusion of help and error support.},
journal = {SIGCHI Bull.},
month = apr,
pages = {177–183},
numpages = {7}
}

@inproceedings{10.1145/317456.317490,
author = {Whiteside, John and Jones, Sandra and Levy, Paula S. and Wixon, Dennis},
title = {User Performance with Command, Menu, and Iconic Interfaces},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317490},
doi = {10.1145/317456.317490},
abstract = {Performance and subjective reactions of 76 users of varying levels of computer experience were measured with 7 different interfaces representing command, menu, and iconic interface styles. The results suggest three general conclusions:there are large usability differences between contemporary systems,there is no necessary tradeoff between ease of use and ease of learning,interface style is not related to performance or preference (but careful design is).Difficulties involving system feedback, input forms, help systems, and navigation aids occurred in all styles of interface: command, menu, and iconic. New interface technology did not solve old human factors problems.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {185–191},
numpages = {7},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317490,
author = {Whiteside, John and Jones, Sandra and Levy, Paula S. and Wixon, Dennis},
title = {User Performance with Command, Menu, and Iconic Interfaces},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317490},
doi = {10.1145/1165385.317490},
abstract = {Performance and subjective reactions of 76 users of varying levels of computer experience were measured with 7 different interfaces representing command, menu, and iconic interface styles. The results suggest three general conclusions:there are large usability differences between contemporary systems,there is no necessary tradeoff between ease of use and ease of learning,interface style is not related to performance or preference (but careful design is).Difficulties involving system feedback, input forms, help systems, and navigation aids occurred in all styles of interface: command, menu, and iconic. New interface technology did not solve old human factors problems.},
journal = {SIGCHI Bull.},
month = apr,
pages = {185–191},
numpages = {7}
}

@inproceedings{10.1145/317456.317491,
author = {Rosson, Mary Beth},
title = {Listener Training for Speech-Output Applications},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317491},
doi = {10.1145/317456.317491},
abstract = {The specificity of the adaptation to synthetic speech known to occur with practice was examined by giving listeners selective exposure to a subset of English phonemes (a control group was “trained” on analogous materials produced by a human speaker), and then testing their ability to identify words created from both the previously heard and novel phonemes. The results indicated that while synthetic voice training was generally facilitative, it was most helpful in the identification of the sounds heard before. However, this specific learning effect occured for only certain phonemes. The findings imply that one way to maximize early adaptation to synthetic speech is to identify the “learnable” sounds, and to increase users' exposure to them during introductory or training dialogs.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {193–196},
numpages = {4},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317491,
author = {Rosson, Mary Beth},
title = {Listener Training for Speech-Output Applications},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317491},
doi = {10.1145/1165385.317491},
abstract = {The specificity of the adaptation to synthetic speech known to occur with practice was examined by giving listeners selective exposure to a subset of English phonemes (a control group was “trained” on analogous materials produced by a human speaker), and then testing their ability to identify words created from both the previously heard and novel phonemes. The results indicated that while synthetic voice training was generally facilitative, it was most helpful in the identification of the sounds heard before. However, this specific learning effect occured for only certain phonemes. The findings imply that one way to maximize early adaptation to synthetic speech is to identify the “learnable” sounds, and to increase users' exposure to them during introductory or training dialogs.},
journal = {SIGCHI Bull.},
month = apr,
pages = {193–196},
numpages = {4}
}

@inproceedings{10.1145/317456.317492,
author = {Rollins, Ann M.},
title = {Speech Recognition and Manner of Speaking in Noise and in Quiet},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317492},
doi = {10.1145/317456.317492},
abstract = {Currently speech recognition is accomplished by matching spoken utterances with reference patterns of words that were spoken by an individual at an earlier time. Recognition is highly dependent upon background noise. The purpose of this study was to assess the extent to which subjects “manner” of speaking in noise, as separate from the noise itself, affected recognition. Subjects generated reference patterns in quiet and in noise and then spoke lists of digits in quiet and in noise for the speech system to recognize. Noise was delivered over earphones so it would not go into the speech recognition system through the microphone. Training and recognition were done from tape recordings, with the playback level of the tape was always set to the same, intermediate level. The data suggest that manner of speaking, for about half of the subjects is very different in noise compared with quiet. The data also imply that if recognition will be done in both quiet and noise, the safest alternative is to start out with patterns generated in noise.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {197–199},
numpages = {3},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317492,
author = {Rollins, Ann M.},
title = {Speech Recognition and Manner of Speaking in Noise and in Quiet},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317492},
doi = {10.1145/1165385.317492},
abstract = {Currently speech recognition is accomplished by matching spoken utterances with reference patterns of words that were spoken by an individual at an earlier time. Recognition is highly dependent upon background noise. The purpose of this study was to assess the extent to which subjects “manner” of speaking in noise, as separate from the noise itself, affected recognition. Subjects generated reference patterns in quiet and in noise and then spoke lists of digits in quiet and in noise for the speech system to recognize. Noise was delivered over earphones so it would not go into the speech recognition system through the microphone. Training and recognition were done from tape recordings, with the playback level of the tape was always set to the same, intermediate level. The data suggest that manner of speaking, for about half of the subjects is very different in noise compared with quiet. The data also imply that if recognition will be done in both quiet and noise, the safest alternative is to start out with patterns generated in noise.},
journal = {SIGCHI Bull.},
month = apr,
pages = {197–199},
numpages = {3}
}

@inproceedings{10.1145/317456.317493,
author = {Waterworth, John A.},
title = {Why is Synthetic Speech Harder to Remember than Natural Speech?},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317493},
doi = {10.1145/317456.317493},
abstract = {Previous research has demonstrated that synthetic speech is less well recalled than natural speech. Luce et al (1983) concluded that this was because synthetic speech increases the effort involved in encoding and/or rehearsal of presented information. Results of the experiments described here, which involved ordered recall of lists of ten words spoken in either a synthetic or a natural voice, with repetition of the words as a measure of successful encoding, indicate that most of the memory deficit with synthetic speech is due to encoding difficulties, rather than problems with item retention. There is evidence that encoding synthetic speech involves more processing capacity than does encoding natural speech, but that once it is encoded it is stored just as efficiently.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {201–206},
numpages = {6},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317493,
author = {Waterworth, John A.},
title = {Why is Synthetic Speech Harder to Remember than Natural Speech?},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317493},
doi = {10.1145/1165385.317493},
abstract = {Previous research has demonstrated that synthetic speech is less well recalled than natural speech. Luce et al (1983) concluded that this was because synthetic speech increases the effort involved in encoding and/or rehearsal of presented information. Results of the experiments described here, which involved ordered recall of lists of ten words spoken in either a synthetic or a natural voice, with repetition of the words as a measure of successful encoding, indicate that most of the memory deficit with synthetic speech is due to encoding difficulties, rather than problems with item retention. There is evidence that encoding synthetic speech involves more processing capacity than does encoding natural speech, but that once it is encoded it is stored just as efficiently.},
journal = {SIGCHI Bull.},
month = apr,
pages = {201–206},
numpages = {6}
}

@inproceedings{10.1145/317456.317494,
author = {Polson, Peter G. and Kieras, David E.},
title = {A Quantitative Model of the Learning and Performance of Text Editing Knowledge},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317494},
doi = {10.1145/317456.317494},
abstract = {A model of manuscript editing, implemented as a simulation program, is described in this paper. The model provides an excellent, quantitative description of learning, transfer, and performance data from two experiments on text editing methods. Implications of the underlying theory for the design process are briefly discussed.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {207–212},
numpages = {6},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317494,
author = {Polson, Peter G. and Kieras, David E.},
title = {A Quantitative Model of the Learning and Performance of Text Editing Knowledge},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317494},
doi = {10.1145/1165385.317494},
abstract = {A model of manuscript editing, implemented as a simulation program, is described in this paper. The model provides an excellent, quantitative description of learning, transfer, and performance data from two experiments on text editing methods. Implications of the underlying theory for the design process are briefly discussed.},
journal = {SIGCHI Bull.},
month = apr,
pages = {207–212},
numpages = {6}
}

@inproceedings{10.1145/317456.317495,
author = {John, Bonnie E. and Rosenbloom, Paul S. and Newell, Allen},
title = {A Theory of Stimulus-Response Compatibility Applied to Human-Computer Interaction},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317495},
doi = {10.1145/317456.317495},
abstract = {A GOMS theory of stimulus-response compatibility is presented and applied to remembering computer command abbreviations. Two abbreviation techniques, vowel-deletion and special-character-plus-first-letter, are compared in an encoding task. Significant differences are found in the time to type the first letter of the abbreviation, and in the time to complete the typing of the abbreviation. These differences are analyzed using the theory which produces an excellent quantitative fit to the data (r2 = 0.97).},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {213–219},
numpages = {7},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317495,
author = {John, Bonnie E. and Rosenbloom, Paul S. and Newell, Allen},
title = {A Theory of Stimulus-Response Compatibility Applied to Human-Computer Interaction},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317495},
doi = {10.1145/1165385.317495},
abstract = {A GOMS theory of stimulus-response compatibility is presented and applied to remembering computer command abbreviations. Two abbreviation techniques, vowel-deletion and special-character-plus-first-letter, are compared in an encoding task. Significant differences are found in the time to type the first letter of the abbreviation, and in the time to complete the typing of the abbreviation. These differences are analyzed using the theory which produces an excellent quantitative fit to the data (r2 = 0.97).},
journal = {SIGCHI Bull.},
month = apr,
pages = {213–219},
numpages = {7}
}

@inproceedings{10.1145/317456.317496,
author = {Dyck, Jennifer L. and Mayer, Richard E.},
title = {BASIC versus Natural Language: Is There One Underlying Comprehension Process?},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317496},
doi = {10.1145/317456.317496},
abstract = {This study determined the response time (RT) for subjects to comprehend eight different BASIC statements and eight corresponding English procedural statements. First, there was no significant interaction between language and statement, and there was a high correlation (r = .85) between English and BASIC RT performance. Second, the microstructure of each statement (the number of actions required) and the macrostructure (the number of other statements in the program) were strongly related to RT performance for both BASIC and English. Apparently, comprehension of procedural statements is related to underlying structural characteristics common to both languages.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {221–223},
numpages = {3},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317496,
author = {Dyck, Jennifer L. and Mayer, Richard E.},
title = {BASIC versus Natural Language: Is There One Underlying Comprehension Process?},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317496},
doi = {10.1145/1165385.317496},
abstract = {This study determined the response time (RT) for subjects to comprehend eight different BASIC statements and eight corresponding English procedural statements. First, there was no significant interaction between language and statement, and there was a high correlation (r = .85) between English and BASIC RT performance. Second, the microstructure of each statement (the number of actions required) and the macrostructure (the number of other statements in the program) were strongly related to RT performance for both BASIC and English. Apparently, comprehension of procedural statements is related to underlying structural characteristics common to both languages.},
journal = {SIGCHI Bull.},
month = apr,
pages = {221–223},
numpages = {3}
}

@inproceedings{10.1145/317456.317497,
author = {Buxton, William A. S. and Reed, David R. and Tesler, Larry and MacGregor, Scott and Greif, Irene},
title = {Microcomputer User Interface Toolkits (Panel Session): The Commercial State-of-the-Art},
year = {1985},
isbn = {0897911490},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/317456.317497},
doi = {10.1145/317456.317497},
abstract = {A well-designed user interface is a very valuable asset: the best available today are based on hundreds of man-years of work combining results of research in human factors, tasteful design reviewed and modified through extensive end-user testing, and many rounds of implementation effort. As a result, the user interface “toolkit” is emerging as the hottest new software item. A toolkit can provide software developers with a programming environment in which the user interface coding is already done so that new applications programs can automatically be integrated with other workstation functions.The panel will evaluate this new trend. Tesler and MacGregor, will present the designs of the leading toolkit products from Apple and Microsoft, respectively. Reed will analyze the choices from the point of view of the third party software vendors' requirements. Noting that the effort going into these products may well result in de facto standard setting, Buxton will question the appropriateness of making this commitment based on microcomputer hardware.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {225},
numpages = {1},
location = {San Francisco, California, USA},
series = {CHI '85}
}

@article{10.1145/1165385.317497,
author = {Buxton, William A. S. and Reed, David R. and Tesler, Larry and MacGregor, Scott and Greif, Irene},
title = {Microcomputer User Interface Toolkits (Panel Session): The Commercial State-of-the-Art},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {4},
issn = {0736-6906},
url = {https://doi.org/10.1145/1165385.317497},
doi = {10.1145/1165385.317497},
abstract = {A well-designed user interface is a very valuable asset: the best available today are based on hundreds of man-years of work combining results of research in human factors, tasteful design reviewed and modified through extensive end-user testing, and many rounds of implementation effort. As a result, the user interface “toolkit” is emerging as the hottest new software item. A toolkit can provide software developers with a programming environment in which the user interface coding is already done so that new applications programs can automatically be integrated with other workstation functions.The panel will evaluate this new trend. Tesler and MacGregor, will present the designs of the leading toolkit products from Apple and Microsoft, respectively. Reed will analyze the choices from the point of view of the third party software vendors' requirements. Noting that the effort going into these products may well result in de facto standard setting, Buxton will question the appropriateness of making this commitment based on microcomputer hardware.},
journal = {SIGCHI Bull.},
month = apr,
pages = {225},
numpages = {1}
}

