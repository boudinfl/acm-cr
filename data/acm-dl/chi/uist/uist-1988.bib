@inproceedings{10.1145/62402.62403,
author = {Kleyn, Michael F. and Chakravarty, Indranil},
title = {EDGE - a Graph Based Tool for Specifying Interaction},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62403},
doi = {10.1145/62402.62403},
abstract = {This paper describes a new methodology for specifying and constructing complex interaction dialogs for the design of user interfaces. The method is new in that it promotes a decomposition of the interaction in terms of events in AND/OR graphs called Event-Decomposition Graphs (EDG). These Event-Decomposition Graphs can be progressively refined to capture the detailed semantics of the dialog. Multithreaded interaction can be composed by joining several Event-Decomposition Graphs together in a systematic way. In this paper we present a design tool for specifying and analyzing Event-Decomposition Graphs, and show that the combination of the notation and tool combines many of the capabilities of Context-Free Grammar- and Event-Notations while still providing the graphical view of Transition Network diagrams.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {1–14},
numpages = {14},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62404,
author = {Rumbaugh, James},
title = {State Trees as Structured Finite State Machines for User Interfaces},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62404},
doi = {10.1145/62402.62404},
abstract = {State trees are a technique for specifying the control of an interactive system by organizing states into trees to define shared structure and behavior. The tree structure permits inheritance of state information, event traps, and entry and exit actions from states to substates, thereby sharing information and reducing the amount of code to be written. An interface can be restructured by moving entire subtrees as modules. State trees separate the recognition of commands from their implementation, allowing either to be modified independently. State trees structure flow of control within an implementation without imposing an identical structure on the interface itself, which need not be hierarchical. State trees have been implemented in an object-oriented language and used to write interactive applications.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {15–29},
numpages = {15},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62405,
author = {Rhyne, James R.},
title = {Extensions to C for Interface Programming},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62405},
doi = {10.1145/62402.62405},
abstract = {Extending the facilities available to a programmer can be more productive, flexible, and appealing when done via additions to the syntax and semantics of the programming language, than when done by way of procedure packages. Database programming, for example, is now routinely done using query languages that are embedded in programming languages.Interaction dialog programming can be greatly simplified by use of a specification language. Dialog languages are not often integrated with a programming language. In this report, a set of extensions to the C language are presented. These extensions provide a rule-based sublanguage for describing interaction dialogs. A translator and interpreter have been constructed for the extended (C + Dialog) language, and used in a research project investigating gestural interfaces.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {30–45},
numpages = {16},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62407,
author = {McCormack, Joel and Asente, Paul},
title = {An Overview of the X Toolkit},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62407},
doi = {10.1145/62402.62407},
abstract = {The X11 Window System defines a network protocol [6] for communication between a graphics server and an application. The X library [3] provides a procedural interface to the protocol.The X toolkit [4] is an object-oriented construction kit built on top of the X library. The toolkit is used to write user interface components (“widgets”), to organize a set of widget instances into a complete user interface, and to link a user interface with the functionality provided by an application.This paper describes the capabilities and structure of the X toolkit from three viewpoints: application developer, widget writer, and application user. We discuss the toolkit's mechanisms to address inefficiencies caused by the separation of application and server, and by the extensive user configurability of toolkit-based applications. We point out some drawbacks to using the toolkit, and briefly describe the tools being developed to overcome these problems.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {46–55},
numpages = {10},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62411,
author = {Binding, Carl},
title = {The Architecture of a User Interface Toolkit},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62411},
doi = {10.1145/62402.62411},
abstract = {This paper describes an architecture for a user interface toolkit. It presents the proper layering of the software, describes the architectural model of user interface components or tools, and discusses the software engineering implications of the architecture. We also present a sample toolkit that was built using the presented architecture and that has been in use since 1985.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {56–65},
numpages = {10},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62413,
author = {Hauge, Tor and Nordgard, Inger and Oscarsson, Dan and Raeder, Georg},
title = {Event-Driven User Interfaces Based on Quasi-Parallelism},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62413},
doi = {10.1145/62402.62413},
abstract = {The Mj\o{}lner project is a major Scandinavian effort to develop a programming environment for object-oriented languages. As part of this project we have implemented a user interaction toolkit. The toolkit is programmed in SIMULA™ and is built on the X Window System.™ The main goals of our work have been to exploit the coroutine concept for event handling, and to show the benefits of using compiled object-oriented languages for this type of software. The result is an efficient system with a simple, yet flexible, design featuring a powerful unification of process-driven and procedure-driven programming styles.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {66–76},
numpages = {11},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62414,
author = {McDonald, James E. and Vandenberg, Paul D. J. and Smartt, Melissa J.},
title = {The Mirage Rapid Interface Prototyping System},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62414},
doi = {10.1145/62402.62414},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {77–84},
numpages = {8},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62416,
author = {Kimbrough, Kerry and Oren, LaMott},
title = {Clue: A Common Lisp User Interface Environment},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62416},
doi = {10.1145/62402.62416},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {85–94},
numpages = {10},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62417,
author = {Borenstein, Nathaniel S. and Gosling, James},
title = {UNIX Emacs: A Retrospective (Lessons for Flexible System Design)},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62417},
doi = {10.1145/62402.62417},
abstract = {UNIX Emacs is well-known and widely used as a text editor that has been extended in a remarkable number of directions, not always wisely. Because it is programmable in a powerful yet simple programming language, Emacs has been used as a development tool for the construction of some remarkably complex user-oriented programs. Indeed, it has served as both a user interface management system and a user interface toolkit, though it was designed as neither. In this paper, we discuss the features that have made it so popular for user interface development, in an attempt to derive lessons of value for more powerful and more systematically designed systems in the future.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {95–101},
numpages = {7},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62420,
author = {Olsen, Dan R. and Halversen, Bradley W.},
title = {Interface Usage Measurements in a User Interface Management System},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62420},
doi = {10.1145/62402.62420},
abstract = {User Interface Management Systems have provided support for most user interface design personnel with the exception of dialogue evaluators. Potential support that a UIMS can provide to evaluators of user interfaces generated by the UIMS are discussed. Metrics for measuring interactive behavior have been implemented as part of a User Interface Management System. It is shown how the external control and separate dialogue description features of UIMSs make possible such measurements. These metrics are automatically mapped back to the responsible portions of the dialogue description. Reports are generated which aid interface evaluators in locating specific problems in a user interface design.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {102–108},
numpages = {7},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62422,
author = {Singh, Gurminder and Green, Mark},
title = {Designing the Interface Designer's Interface},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62422},
doi = {10.1145/62402.62422},
abstract = {The concepts of a user interface management system (UIMS) and user interface designer have become well known in the user interface and graphics community. Most UIMSs developed so far have concentrated on the efficiency of generating the user interface; the user interface designer's interface has received relatively little attention. We identify the important features of the user interface designer's interface. A UIMS incorporating these features in its interface has been developed, and is described in this paper.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {109–116},
numpages = {8},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62424,
author = {Meier, Barbara J.},
title = {ACE: A Color Expert System for User Interface Design},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62424},
doi = {10.1145/62402.62424},
abstract = {Color is used in computer graphics to code information, to call attention to items, to signal a user, and to enhance display aesthetics, but using color effectively and tastefully is often beyond the abilities of application programmers because the study of color crosses many disciplines, and many aspects, such as human color vision, are not completely understood. We compiled a comprehensive set of guidelines for the proper use of color, but even these guidelines cannot provide all of the aesthetic and human factors knowledge necessary for making good color selections. Furthermore, programmers may misinterpret or ignore the guidelines. To alleviate some of these problems, we have implemented ACE, A Color Expert system which embodies the color rules and applies them to user interface design. The goal of the implementation was to test whether an automated mechanism would be a viable solution to the problem of choosing effective and tasteful colors.Our implementation is written in OPS5, a production system programming language, which allowed us encode rules in a similar fashion to our existing set of guidelines. ACE takes a user interface specification and uses our color rules as constraints to determine the best colors for particular items. While ACE is only a prototype, we learned that an expert system is a viable method for choosing an initial set of colors that can be “tweaked” by a human expert. We also learned that much more research needs to be performed in the areas of visual color relationships and how they can be used to provide the most effective user interface.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {117–128},
numpages = {12},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62425,
author = {Giacalone, Alessandro},
title = {XY-WINS: An Integraded Environment for Developing Graphical User Interfaces},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62425},
doi = {10.1145/62402.62425},
abstract = {XY-WINS is an integrated environment that supports design, prototyping, implementation, and debugging of graphical user interfaces. XY-WINS tools allow user interface designers to work at an abstract level, thus enabling non-experts in computer graphics to quickly prototype graphical interfaces. However, the tools also allow great flexibility in defining graphical features. XY-WINS supports the development of user interfaces consisting of two main modules: a Graphical Abstract Machine (GRAM), and a High-level Interaction Component (HIC). The GRAM encapsulates the lower levels of input and output, and provides the HIC with an abstract view of the user based on abstract representations of pictures and on input tokens incoming through input channels. The HIC implements the dialogue between this abstraction of the user and the back-end of the system.The environment provides tools for generating a GRAM from abstract specifications of the graphical constructs and the input tokens that are to be used in a user interface. These specifications can be edited interactively and graphically. The HIC can be specified as a system of independent communicating processes/objects by using a high-level concurrent language, which also includes control structures designed to support the definition of complex user/system interactions. Finally, an interactive debugging system allows one to execute the user interface, while simultaneously visualizing end-user screen, state of the GRAM, and state of the HIC.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {129–143},
numpages = {15},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62426,
author = {Smith, David N.},
title = {Building Interfaces Interactively},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62426},
doi = {10.1145/62402.62426},
abstract = {The Interface Construction Set (InterCONS) is a visual language and environment. It consists of: a data flow language; an editor for building and testing data flow programs, and for making presentation views of the programs; libraries for holding completed programs; and a presentation system for interacting with finished programs and sequences of programs.This paper describes how interfaces are built using the data flow language. A companion paper describes the data flow language and its primitives for arithmetic, logic, interactive control, path control, visual output, and program control; the execution model is also described.InterCONS is useful for experimenting with new kinds of interactive controls, and building models of interactive applications.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {144–151},
numpages = {8},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62428,
author = {Cardelli, Luca},
title = {Building User Interfaces by Direct Manipulation},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62428},
doi = {10.1145/62402.62428},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {152–166},
numpages = {15},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62429,
author = {Henry, Tyson R. and Hudson, Scott E.},
title = {Using Active Data in a UIMS},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62429},
doi = {10.1145/62402.62429},
abstract = {An active data model is one that not only stores data, but also acts upon changes to the data in ways that reflect application domain semantics. This paper introduces an active object-oriented model based on incremental attribute evaluation (one-way constraints) and discusses how it can be used to support a number of tasks in a User Interface Management System. It is shown how this model can provide unified support for lexical, syntactic, and semantic feedback, how the model supports the specification and implementation of dynamically changing graphical layouts, and how the model can be used as the basis for support of user extensible interfaces.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {167–178},
numpages = {12},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62431,
author = {Mackinlay, Jock},
title = {Applying a Theory of Graphical Presentation to the Graphic Design of User Interfaces},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62431},
doi = {10.1145/62402.62431},
abstract = {The increasing availability of computers with high-quality graphics and fonts has created an opportunity and an obligation for user interface designers. The opportunity is that designers can use graphical techniques to design more effective user interfaces. The obligation is that they must become experts at the design of graphical user interfaces. Current user interface toolkits provide very little design assistance. This paper describes a theory that supports automatic design of graphical presentations of relational information and shows how to extend it to support theory-driven design of graphical user interfaces.“A picture worth a thousand words must first be a good picture” [Bow68]},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {179–189},
numpages = {11},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62433,
author = {Sukaviriya, Piyawadee},
title = {Dynamic Construction of Animated Help from Application Context},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62433},
doi = {10.1145/62402.62433},
abstract = {Help provided as traditional text descriptions has become incompatible with graphical interfaces. Animation suggests a better association between help and a graphical interface. This paper describes a prototype system implemented to demonstrate the use of dynamic scenarios as help. A scenario animates the execution of a task as a sequence of steps in the actual interface and work context. Each scenario is dynamically generated depending on the current work context of the user. The system reasons from the user's request for help as well as from the context what and how much to animate.In addition to the animation driving mechanism, construction of animated help requires knowledge about application semantics, user interface semantics, user interface syntax and application context. The application semantics determines the steps needed to satisfy the help request. The user interface semantics determines whether the current state of the graphical interface will support the appropriate animated help scenarios. The user interface syntax gives detailed information on how each step will actually be performed. Preconditions are used in both application and user interface semantics for reasoning in help construction. The restoring of context is performed using help session history data to return to the original work context after an animation session.The implemented example uses a directory tree program where the graphical interface is kept simple. In future research the concept will be applied to more complicated applications.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {190–202},
numpages = {13},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62434,
author = {Teran, Marcelo and Rasure, John and Argiro, Danielle and Hallett, Stephanie and Neher, Ron and Young, Mark and Wilson, Scott},
title = {XVISION: A Comprehensive Software System for Image Processing Research, Education, and Applications},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62434},
doi = {10.1145/62402.62434},
abstract = {XVision is a software system for image processing research, education and applications. Xyvision utilizes the X Window System Version 11, which provides a network transparent windowing environment and software portability. Xyvision is designed to facilitate:
data and algorithm exchange of new computer vision/image processing techniques,image processing training and education,development of turn key vision solutions for various application areas (automation, medicine, biology, astronomy, etc).XVision is a comprehensive system because it supports generation of new programs (extendibility), and integration, maintenance, modification and documentation of existing programs; and it includes:
three user interfaces; a menuing system, a quick command line interface that can be customized and a standardized UNIX‡-like command line interface. A visual programming language, xvglyph, is under development.tutorials, manual pages, experiments, automated demonstrations and other supplemental documentation.an image processing library written in C,interactive image display and enhancement, image editing and creation, 2D, 3D, and contour plotting, and data creation/display via user specified functions.The Xyvision project started in February of 1987 with its first release in August of 1987. This paper describes the second version which incorporates changes suggested by many of the users (over 30 different institutions) of Xyvision Version 1.0 [1]. One of the most important design goals of the Xyvision project is to provide for easy growth and extendibility. This has been accomplished by clearly defining software levels, software systems and their standard interfaces, and by providing programming tools and a variety of user interfaces for the Xyvision user/maintainer.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {203–210},
numpages = {8},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62435,
author = {Guarna, Vincent A. and Gaur, Yogesh},
title = {A Portable User Interface for a Scientific Programming Environment},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62435},
doi = {10.1145/62402.62435},
abstract = {The subject of integrated programming environments for scientific computing has become very popular over the last few years. Environments such as Rn [CCHK87] are being constructed to help coordinate the disjoint activities of editing, debugging, and performance tuning typically seen in the program development cycle. One key aspect of an integrated development setting is the library of user interface tools which are available to the environment builders. Projects such as Andrew [MSCH86] have begun to construct reusable user interface libraries for client applications. This paper describes the interface tool kit for the Faust project being conducted at the University of Illinois. Faust is targeted at building a coherent development environment for scientific applications through the use of a library of portable user interface utilities.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {211–220},
numpages = {10},
location = {Alberta, Canada},
series = {UIST '88}
}

@inproceedings{10.1145/62402.62436,
author = {Phillips, Cary B. and Badler, Norman I.},
title = {JACK: A Toolkit for Manipulating Articulated Figures},
year = {1988},
isbn = {0897912837},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62402.62436},
doi = {10.1145/62402.62436},
abstract = {The problem of positioning and manipulating three dimensional articulated figures is often handled by ad hoc techniques which are cumbersome to use. In this paper, we describe a system which provides a consistent and flexible user interface to a complex representation for articulated figures in a 3D environment. Jack is a toolkit of routines for displaying and manipulating complex geometric figures, and it provides a method of interactively manipulating arbitrary homogeneous transformations with a mouse. These transformations may specify the position and orientation of figures within a scene or the joint transformations within the figures themselves. Jack combines this method of 3D input with a flexible and informative screen management facility to provide a user-friendly interface for manipulating three dimensional objects.},
booktitle = {Proceedings of the 1st Annual ACM SIGGRAPH Symposium on User Interface Software},
pages = {221–229},
numpages = {9},
location = {Alberta, Canada},
series = {UIST '88}
}

