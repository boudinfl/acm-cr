@inproceedings{10.1145/182591.182592,
author = {Harel, David},
title = {Will I Be Pretty, Will I Be Rich? Some Thoughts on Theory vs. Practice in Systems Engineering},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182592},
doi = {10.1145/182591.182592},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {1–3},
numpages = {3},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182593,
author = {Faloutsos, Christos and Kamel, Ibrahim},
title = {Beyond Uniformity and Independence: Analysis of R-Trees Using the Concept of Fractal Dimension},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182593},
doi = {10.1145/182591.182593},
abstract = {We propose the concept of fractal dimension of a set of points, in order to quantify the deviation from the uniformity distribution. Using measurements on real data sets (road intersections of U.S. counties, star coordinates from NASA's Infrared-Ultraviolet Explorer etc.) we provide evidence that real data indeed are skewed, and, moreover, we show that they behave as mathematical fractals, with a measurable, non-integer fractal dimension.Armed with this tool, we then show its practical use in predicting the performance of spatial access methods, and specifically of the R-trees. We provide the first analysis of R-trees for skewed distributions of points: We develop a formula that estimates the number of disk accesses for range queries, given only the  fractal dimension of the point set, and its count. Experiments on real data sets show that the formula is very accurate: the relative error is usually below 5%, and it rarely exceeds 10%.We believe that the fractal dimension will help replace the uniformity and independence assumptions, allowing more accurate analysis for any spatial access method, as well as better estimates for query optimization on multi-attribute queries.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {4–13},
numpages = {10},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182594,
author = {Haas, Peter J. and Naughton, Jeffrey F. and Swami, Arun N.},
title = {On the Relative Cost of Sampling for Join Selectivity Estimation},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182594},
doi = {10.1145/182591.182594},
abstract = {We compare the cost of estimating the selectivity of a “star join” using sampling procedure t-cross to the cost of simply computing the join and obtaining the exact answer. Our bounds and approximations for the relative cost of sampling show how this cost depends on the size of the input relations, the number of input relations, and the precision criterion used by the estimation procedure. We also demonstrate the deleterious effect of dangling tuples and the mixed effect of data skew on the relative cost of sampling. These results provide insight into when sampling should or should not be used for join selectivity estimation.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {14–24},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182595,
author = {Ramaswamy, Sridhar and Subramanian, Sairam},
title = {Path Caching (Extended Abstract): A Technique for Optimal External Searching},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182595},
doi = {10.1145/182591.182595},
abstract = {External 2-dimensional searching is a fundamental problem with many applications in relational, object-oriented, spatial, and temporal databases. For example, interval intersection can be reduced to 2-sided, 2-dimensional searching and indexing class hierarchies of objects to 3-sided, 2-dimensional searching. Path caching is a new technique that can be used to transform a number of time/space efficient data structures for internal 2-dimensional searching (such as segment trees, interval trees, and priority search trees) into I/O efficient external ones. Let n be the size of the database, B the page size, and t the output size of a query. Using path caching, we provide the first data structure with optimal I/O query time O(logBn+t/B) for 2-sided, 2-dimensional searching. Furthermore, we show that path caching requires a small space overhead O(nundefinedBlog2log2B) and is simple enough to admit dynamic updates in optimal O(logBn) amortized time. We also extend this data structure to handle 3-sided, 2-dimensional searching with optimal I/O query-time, at the expense of slightly higher storage and update overheads.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {25–35},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182596,
author = {Chen, Ling Tony and Rotem, Doron},
title = {Optimal Response Time Retrieval of Replicated Data (Extended Abstract)},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182596},
doi = {10.1145/182591.182596},
abstract = {This work deals with the problem of finding efficient access plans for retrieving a set of pages from a multi-disk system with replicated data. This paper contains two results related to this problem: (a) We solve the problem of finding an optimal access path by transforming it into a network flow problem. We also indicate how our method may be employed in dynamic environments where some (or all) of the disks have a preexisting load, are heterogeneous, and reside on different servers. (b) We present a lower bound for the worst case response time of a request under all replication schemes, and also discuss the replication scheme that results in this lower bound. We then use simulation to show how this replication scheme can also greatly reduce the average case response time.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {36–44},
numpages = {9},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182597,
author = {Gupta, Ashish and Sagiv, Yehoshua and Ullman, Jeffrey D. and Widom, Jennifer},
title = {Constraint Checking with Partial Information},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182597},
doi = {10.1145/182591.182597},
abstract = {Constraints are a valuable tool for managing information across multiple databases, as well as for general purposes of assuring data integrity. However, efficient implementation of constraint checking is difficult. In this paper we explore techniques for assuring constraint satisfaction without performing a complete evaluation of the constraints. We consider methods that use only constraint definitions, methods that use constraints and updates, and methods that use constraints, updates, and “local” data.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {45–55},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182598,
author = {Stuckey, Peter J. and Sudarshan, S.},
title = {Compiling Query Constraints (Extended Abstract)},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182598},
doi = {10.1145/182591.182598},
abstract = {We present a general technique to push query constraints (such as length≤1000) into database views and (constraint) logic programs. We introduce the notion of parametrized constraints, which help us push constraints with argument values that are known only at run time, and develop techniques for pushing parametrized constraints into predicate/view definitions. Our technique provides a way of compiling programs with constraint queries into programs with parametrized constraints compiled in, and which can be executed on systems, such as database query evaluation systems, that do not handle full constraint solving. Thereby our technique can push constraint selections that earlier constraint query rewriting techniques could not. Our technique is independent of the actual constraint domain, and we illustrate its use with equality constraints on structures (which are useful in object-oriented query languages) and linear arithmetic constraints.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {56–67},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182599,
author = {Sohn, Kirack},
title = {Constraints among Argument Sizes in Logic Programs (Extended Abstract)},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182599},
doi = {10.1145/182591.182599},
abstract = {In logic programs the argument sizes of derivable facts w.r.t. an n-ary predicate are viewed as a set of points in Rn, which are approximated by their convex hull. Interargument constraint w.r.t. a predicate is essentially  a set of constraints that every derivable fact of the predicate satisfies. We formalize such constraints by a fixpoint of recursive transformation similar to immediate consequence operator. However, the transformation does not necessarily converge finitely. Approximating polycones to their affine hulls provides useful interargument constraints in many practical programs, guaranteeing finite convergence. For a class of linear recursive logic programs satisfying  translativeness property, precise interargument constraints can be obtained by an analysis of structures of recursive transformations.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {68–74},
numpages = {7},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182600,
author = {Agrawal, Rakesh},
title = {Tutorial Database Mining},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182600},
doi = {10.1145/182591.182600},
abstract = {We view database mining as the efficient construction and verification of models of patterns embedded in large databases. Many of the database mining problems have been motivated by the practical decision support problems faced by most large retail organizations. In the Quest project at the IBM Almaden Research center, we have focussed on three classes of database mining problems involving classification, associations, and sequences. In this tutorial, I will draw upon my Quest experience to present my perspective of database mining, describe current work, and present some open problems.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {75–76},
numpages = {2},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182601,
author = {Kivinen, Jyrki and Mannila, Heikki},
title = {The Power of Sampling in Knowledge Discovery},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182601},
doi = {10.1145/182591.182601},
abstract = {We consider the problem of approximately verifying the truth of sentences of tuple relational calculus in a given relation M by considering only a random sample of M. We define two different measures for the error of a universal sentence in a relation. For a set of n universal sentences each with at most k universal quantifiers, we give upper and lower bounds for the sample sizes required for having a high probability that all the sentences with error at least ε can be detected as false by considering the sample. The sample sizes are O((log n)/ε) or O((|M|1–1/k)log n/ε), depending on the error measure used. We also  consider universal-existential sentences.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {77–85},
numpages = {9},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182602,
author = {Chaudhuri, Surajit and Kolaitis, Phokion G.},
title = {Can Datalog Be Approximated?},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182602},
doi = {10.1145/182591.182602},
abstract = {In this paper, we investigate whether recursive Datalog predicates can be approximated by finite unions of conjunctive queries. We introduce a quantitative notion of error and examine two types of approximation, namely, absolute approximation and relative approximation. We also stipulate that the approximations obey certain qualitative criteria, namely we require them to be upper envelopes or lower envelopes of the Datalog predicate they approximate. We establish that absolute approximation by finite unions of conjunctive queries is not possible, which means that no unbounded Datalog predicate can be approximated by a finite union of conjunctive queries in such a way that the error is bounded  uniformly by the same constant on all finite databases. After this, we examine relative approximations, i.e., approximations that guarantee bounds for the error relative to the size of the Datalog predicate under consideration. Although such approximations exist in some cases, we show that for several large and well-studied classes of unbounded Datalog predicates it is not possible to find finite unions of conjunctive queries that satisfy the aforementioned qualitative criteria and have the property that the relative error of the approximation is bounded by a constant. Finally, we consider first-order approximations and obtain sharp negative results for the approximability of the transitive closure query and the cycle query by first-order  queries.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {86–96},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182603,
author = {Afrati, Foto N.},
title = {Bonded Arity Datalog (≠) Queries on Graphs},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182603},
doi = {10.1145/182591.182603},
abstract = {We show that there are Datalog( ≠ ) queries on graphs (i.e., the extensional database contains a single binary relation) that require recursively defined predicates of arbitrarily large width. More specifically, we prove that fixed subgraph homeomorphism queries require width of recursively defined predicates which is at least equal to the number of arcs in the pattern graph.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {97–106},
numpages = {10},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182604,
author = {Chaudhuri, Surajit and Vardi, Moshe Y.},
title = {On the Complexity of Equivalence between Recursive and Nonrecursive Datalog Programs},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182604},
doi = {10.1145/182591.182604},
abstract = {In a previous paper, we have proved tight complexity bounds for the equivalence of recursive and nonrecursive Datalog programs: triply exponential time in general and doubly-exponential space for linear programs. In this paper, we show that under realistic restrictions on the classes programs under consideration, equivalence of recursive and nonrecursive programs can be less intractable; for the classes of programs we consider the complexity of equivalence ranges from NP to co-NEXPTIME.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {107–116},
numpages = {10},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182605,
author = {Hua, Kien A. and Lang, S. D. and Lee, Wen K.},
title = {A Decomposition-Based Simulated Annealing Technique for Data Clustering},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182605},
doi = {10.1145/182591.182605},
abstract = {It has been demonstrated that simulated annealing provides high-quality results for the data clustering problem. However, existing simulated annealing schemes are memory-based algorithms; they are not suited for solving large problems such as data clustering which typically are too big to fit in the memory space in its entirety. Various buffer replacement policies, assuming either temporal or spatial locality, are not useful in this case since simulated annealing is based on a randomized search process. Poor locality of references will cause the memory to thrash because too many replacements are required. This phenomenon will incur excessive disk accesses and force the machine to run at the speed of the I/O subsystem. In this paper, we formulate the data clustering  problem as a graph partition problem (GPP), and propose a decomposition-based approach to address the issue of excessive disk accesses during annealing. We apply the statistical sampling technique to randomly select subgraphs of the GPP into memory for annealing. Both the analytical and experimental studies indicate that the decomposition-based approach can dramatically reduce the costly disk I/O activities while obtaining excellent optimized results.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {117–128},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182606,
author = {Alonso, G. and Agrawal, D. and El Abbadi, A.},
title = {Reducing Recovery Constraints on Locking Based Protocols},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182606},
doi = {10.1145/182591.182606},
abstract = {Serializability is the standard correctness criterion for concurrency control. To ensure correctness in the presence of failures, recoverability is also imposed. Pragmatic considerations result in further constraints, for instance, the existing log-based recovery implementations that use before-images warrant that transaction executions be strict. Strict executions are restrictive, thus sacrificing concurrency and throughput. In this paper we identify the relation between the recovery mechanism and the restrictions imposed by concurrency control protocols. In particular, we propose a new inverse operation that can be integrated with the underlying recovery mechanism. In order to establish the viability of our approach, we demonstrate the new implementation by making minor  modifications to the conventional recovery architecture. This inverse operation is also designed to avoid the undesirable phenomenon of cascading aborts when transactions execute conflicting write operations.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {129–138},
numpages = {10},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182607,
author = {Agrawal, D. and Bruno, J. L. and El Abbadi, A. and Krishnaswamy, V.},
title = {Relative Serializability (Extended Abstract): An Approach for Relaxing the Atomicity of Transactions},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182607},
doi = {10.1145/182591.182607},
abstract = {In the presence of semantic information, serializability is too strong a correctness criterion and unnecessarily restricts concurrency. We use the semantic information of a transaction to provide different atomicity views of the transaction to other transactions. The proposed approach improves concurrency and allows interleavings among transactions which are non-serializable, but which nonetheless preserve the consistency of the database and are acceptable to other users. We develop a graph-based tool whose acyclicity is both a necessary and sufficient condition for the correctness of an execution. Our theory encompasses earlier proposals that incorporate semantic information of transactions. Furthermore it is the first approach that provides an efficient graph based tool for  recognizing correct schedules without imposing any restrictions on the application domain. Our approach is widely applicable to many advanced database applications such as systems with long-lived transactions and collaborative environments.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {139–149},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182608,
author = {Tannen, Val},
title = {Tutorial: Languages for Collection Types},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182608},
doi = {10.1145/182591.182608},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {150–154},
numpages = {5},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182609,
author = {Libkin, Leonid and Wong, Limsoon},
title = {New Techniques for Studying Set Languages, Bag Languages and Aggregate Functions},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182609},
doi = {10.1145/182591.182609},
abstract = {We provide new techniques for the analysis of the expressive power of query languages for nested collections. These languages may use set or bag semantics and may be further complicated by the presence of aggregate functions. We exhibit certain classes of graphs and prove that the properties of these graphs that can be tested in such languages are either finite or cofinite. This result settles the conjectures of Grumbach, Milo, and Paredaens that parity test, transitive closure, and balanced binary tree test are not expressible in bag languages like the PTIME fragment of BALG of Grumbach and Milo and BQL of Libkin and Wong. Moreover, it implies that many recursive queries, including simple ones like the test for a chain, cannot be expressed in a nested relational language even when aggregate functions are available. In an attempt to generalize the finite-cofiniteness result, we study the bounded degree property which says that the number of distinct in- and out-degrees in the output of a graph query does not depend on the size of the input if the input is “simple”. We show that such a property implies a number of inexpressibility results in a uniform fashion. We then prove the bounded degree property for the nested relational language.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {155–166},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182610,
author = {Suciu, Dan and Breazu-Tannen, Val},
title = {A Query Language for NC},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182610},
doi = {10.1145/182591.182610},
abstract = {We show that a form of divide and conquer recursion on sets together with the relational algebra expresses exactly the queries over ordered relational databases which are NC-computable. At a finer level, we relate k nested uses of recursion exactly to ACk, k≥1. We also give corresponding results for complex objects.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {167–178},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182611,
author = {Colby, Latha S. and Robertson, Edward L. and Saxton, Lawrence V. and Van Gucht, Dirk},
title = {A Query Language for List-Based Complex Objects},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182611},
doi = {10.1145/182591.182611},
abstract = {We present a language for querying list-based complex objects. The language is shown to express precisely the polynomial-time generic list-object functions. The iteration mechanism of the language is based on a new approach wherein, in addition to the list over which the iteration is performed, a second list is used to control the number of iteration steps. During the iteration, the intermediate results can be moved to the output list as well as reinserted into the list being iterated over. A simple syntactic constraint allows the growth rate of the intermediate results to be tightly controlled which, in turn, restricts the expressiveness of the language to PTIME.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {179–189},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182612,
author = {Mumick, Inderpal Singh and Shmueli, Oded},
title = {Universal Finiteness and Satisfiability (Extended Abstract)},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182612},
doi = {10.1145/182591.182612},
abstract = {The problem of determining whether, for every extensional database, a given predicate in a given program has a finite number of derivations is called the universal finiteness problem. The problem of determining whether a given predicate in a given program has a non-empty extension for some extensional database is called the satisfiability problem. We show that the universal finiteness problem can be reduced to the satisfiability problem. Thus all decidability results for satisfiability can be applied to universal finiteness—for example, we can infer that the universal finiteness problem is decidable for Datalog extended with negation on base predicates. The satisfiability problem can be easily reduced to the universal finiteness problem, so that all undecidability results for  satisfiability can be applied to universal finiteness. For example we can infer that the universal finiteness problem is undecidable for Datalog extended with stratified negation.Many recursive programs have infinite number of derivations only when ed b relations have data cycles. It is thus of particular interest to study universal finiteness in the presence of acyclicity constraints on the ed b relations. We define acyclicity constraints in terms of non-satisfiability of a specific recursive program. We show that both the problems of universal finiteness and satisfiability of Datalog in the presence of acyclicity constraints (on one or more ed b relations) remain decidable for a language L whenever the problems are decidable for language L in  absence of such constraints. We also show that the problems are undecidable for arbitrary constraints expressed in terms of non-satisfiability of a recursive program.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {190–200},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182613,
author = {Suciu, Dan and Paredaens, Jan},
title = {Any Algorithm in the Complex Object Algebra with Powerset Needs Exponential Space to Compute Transitive Closure},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182613},
doi = {10.1145/182591.182613},
abstract = {The Abiteboul and Beeri algebra for complex objects can express a query whose meaning is transitive closure, but the algorithm is naturally associated to this query needs exponential space. We show that any other query in the algebra which expresses transitive closure needs exponential space. This proves that in general the powerset is an intractable operator for implementing fixpoint queries.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {201–209},
numpages = {9},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182614,
author = {Patnaik, Sushant and Immerman, Neil},
title = {Dyn-FO (Preliminary Version): A Parallel, Dynamic Complexity Class},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182614},
doi = {10.1145/182591.182614},
abstract = {Traditionally, computational complexity has considered only static problems. Classical Complexity Classes such as NC, P, NP, and PSPACE are defined in terms of the complexity of checking—upon presentation of an entire input—whether the input satisfies a certain property.For many, if not most, applications of computers including: databases, text editors, program development, it is more appropriate to model the process as a dynamic one. There is a fairly large object being worked on over a period of time. The object is repeatedly modified by users and computations are performed.Thus a dynamic algorithm for a certain class of queries is one that can maintain an input object, e.g. a database, and process changes to the database as well as answering  queries about the current database.Here, we introduce the complexity class, Dynamic First-Order Logic (Dyn-FO). This is the class of properties S, for which there is an algorithm that can perform inserts, deletes and queries from S, such that each unit insert, delete, or query is first-order computable. This corresponds to the sets of properties that can be maintained and queried in first-order logic, i.e. relational calculus, on a relational database.We investigate the complexity class Dyn-FO. We show that many interesting properties are in Dyn-FO including, among others, graph connectivity, k-edge connectivity, and the computation of minimum spanning trees. Furthermore, we show that several NP complete optimization problems admit approximation algorithms in Dyn-FO. Note that none of these  problems is in static FO, and this fact has been used to justify increasing the power of query languages beyond first-order. It is thus striking that these problems are indeed dynamic first-order, and thus, were computable in first-order database languages all along.We also define “bounded expansion reductions” which honor dynamic complexity classes. We prove that certain standard complete problems for static complexity classes, such as AGAP for P remain complete via these new reductions. On the other hand, we prove that other such problems including GAP for NL and 1GAP for L are no longer complete via bounded expansion reductions. Furthermore, we show that a version of AGAP called AGAP+ is not in Dyn-FO unless all of P is contained in parallel linear  time.Our results shed light on some of the interesting differences between static and dynamic complexity.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {210–221},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182615,
author = {Hillebrand, Gerd G. and Kanellakis, Paris C.},
title = {Functional Database Query Languages as Typed Lambda Calculi of Fixed Order (Extended Abstract)},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182615},
doi = {10.1145/182591.182615},
abstract = {We present a functional framework for database query languages, which is analogous to the conventional logical framework of first-order and fixpoint formulas over finite structures. We use atomic constants of order 0, equality among these constants, variables, application, lambda abstraction, and let abstraction; all typed using fixed order (≤ 5) functionalities. In this framework, proposed in [21] for arbitrary order functionalities, queries and databases are both typed lambda terms, evaluation is by reduction, and the main programming technique is list iteration. We define two families of languages: TLI=i or simply-typed list iteration of order i+3 with equality, and MLI=i or ML-typed list iteration of order i+3 with equality; we use i+3 since our list representation of databases requires at least order 3. We show that: FO-queries ⊆TLI=0 ⊆MLI=0 ⊆LOGSPACE-queries ⊆TLI=1 =MLI=1 = PTIME-queries ⊆ TLI2, where equality is no longer a primitive in TLI2. We also show that ML type inference, restricted to fixed order, is polynomial in the size of the program typed. Since programming by using low order functionalities and type inference is common in functional languages, our results indicate that such programs suffice for expressing efficient computations and that their ML-types can be efficiently inferred.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {222–231},
numpages = {10},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182616,
author = {Mendelzon, Alberto O. and Milo, Tova and Waller, Emmanuel},
title = {Object Migration},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182616},
doi = {10.1145/182591.182616},
abstract = {We study a mechanism that supports the migration of objects from one class of an OODB to another, thereby enabling us to model the same object playing different roles throughout its lifetime. Object migration may introduce typing conflicts due to the different typing constraints imposed by the classes. We present a coercion-like adaptation process that automatically resolves these conflicts. The process combines re-classification of objects and modification of attributes. We study the computational complexity of the problem, and show that the adaptation process can be performed efficiently in databases with covariant schemas.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {232–242},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182620,
author = {Calvanese, Diego and Lenzerini, Maurizio},
title = {Making Object-Oriented Schemas More Expressive},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182620},
doi = {10.1145/182591.182620},
abstract = {Current object-oriented data models lack several important features that would allow one to express relevant knowledge about the classes of schema. In particular, there is no data model supporting simultaneously the inverse of the functions represented by attributes, the union, the intersection and the complement of classes, the possibility of using nonbinary relations, and the possibility of expressing cardinality constraints on attributes and relations. In this paper we define a new data model, called CAR, which extends the basic core of current object-oriented data models with all the above mentioned features. A technique is then presented both for checking the consistency of class definitions, and for computing the logical sequences of the knowledge represented  in the schema. Finally, the inherent complexity of reasoning in CAR is investigated, and the complexity of our inferencing technique is studied, depending on various assumptions on the schema.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {243–254},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182623,
author = {Ohori, Atsushi and Tajima, Keishi},
title = {A Polymorphic Calculus for Views and Object Sharing (Extended Abstract)},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182623},
doi = {10.1145/182591.182623},
abstract = {We present a typed polymorphic calculus that supports a general mechanism for view definition and object sharing among classes. In this calculus, a class can contain inclusion specifications of objects from other classes. Each such specification consists of a predicate determining the subset of objects to be included and a viewing function under which those included objects are manipulated. Both predicates and viewing functions can be any type consistent programs definable in the polymorphic calculus. Inclusion specifications among classes can be cyclic, allowing mutually recursive class definitions. These features achieve flexible view definitions and wide range of class organizations in a compact and elegant way. Moreover, the calculus provides a suitable set of operations for views and classes so that the programmer can manipulate views and classes just the same way as one deals with ordinary records and sets.The proposed calculus uniformly integrates views and classes in a polymorphic type system of a database programming language similar to Machiavelli. The calculus has a type inference algorithm that relieves the programmer from complicated type declarations of views and classes. The polymorphic type system of the calculus is also shown to be sound, which guarantees complete static check of type consistency of programs involving classes and views. Through these properties, the programmer can enjoy full advantages of polymorphism and type inference when writing object-oriented database programs.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {255–266},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182639,
author = {Eiter, Thomas and Gottlob, Georg and Mannila, Heikki},
title = {Adding Disjunction to Datalog (Extended Abstract)},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182639},
doi = {10.1145/182591.182639},
abstract = {We study the expressive power and complexity of disjunctive datalog, i.e., datalog with disjunctive rule heads, under three different semantics: the minimal model semantics, the perfect models semantics, and the stable model semantics. We show that the brave variants of these semantics express the same set of queries. In fact, they precisely capture the complexity of class ΣP/2. The combined complexity of disjunctive datalog is shown to be NEXPTIMENP-complete.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {267–278},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182640,
author = {Paredaens, Jan and Van den Bussche, Jan and Van Gucht, Dirk},
title = {Towards a Theory of Spatial Database Queries (Extended Abstract)},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182640},
doi = {10.1145/182591.182640},
abstract = {A general model for spatial databases is considered, which extends the relational model by allowing as tuple components not only atomic values but also geometrical figures. The model, which is inspired by the work of Kanellakis, Kuper and Revesz on constraint query languages, includes a calculus and an algebra which are equivalent. Given this framework, the concept of spatial database query is investigated. Thereto, Chandra and Harel's well-known consistency criterion for classical relational queries is adapted. Various adaptations are proposed, depending on the kinds of geometry in which the spatial information in the database is to be interpreted. The consistency problem for calculus queries is studied. Expressiveness issues are examined. The main purpose of the paper is to open  up new grounds for theoretical research in the area of spatial database systems. Consequently, many open problems are indicated.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {279–288},
numpages = {10},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182654,
author = {Grumbach, St\'{e}phane and Su, Jianwen},
title = {Finitely Representable Databases (Extended Abstract)},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182654},
doi = {10.1145/182591.182654},
abstract = {We study classes of infinite but finitely representable databases based on constraints, motivated by new database applications such as geographical databases. The mathematical framework is based on classical decidable first-order theories. We investigate the theory of finitely representable models and prove that it differs strongly from both classical model theory and finite model theory. In particular, we show that most of the well known theorems of either one fail (compactness, completeness, locality, 0/1 laws, etc.). An immediate consequence is the lack of tools to consider the definability of queries in the relational calculus over finitely representable databases. We illustrate this very challenging problem through some classical examples.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {289–300},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182655,
author = {Gonnet, Gaston H.},
title = {Text Dominated Databases, Theory Practice and Experience (Abstract)},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182655},
doi = {10.1145/182591.182655},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {301–302},
numpages = {2},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

@inproceedings{10.1145/182591.182656,
author = {Grahne, G\"{o}sta and Nyk\"{a}nen, Matti and Ukkonen, Esko},
title = {Reasoning about Strings in Databases},
year = {1994},
isbn = {0897916425},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/182591.182656},
doi = {10.1145/182591.182656},
abstract = {In order to enable the database programmer to reason about relations over strings of arbitrary length we introduce alignment logic, a modal extension of relational calculus. In addition to relations, a state in the model consists of a two-dimensional array where the strings are aligned on top of each other. The basic modality in the language (a transpose, or “slide”) allows for a rearrangement of the alignment, and more complex formulas can be formed using a syntax reminiscent of regular expressions, in addition to the usual connectives and quantifiers. It turns out that the computational counterpart of the string-based portion of the logic is the class of multitape two-way finite state automata, which are devices particularly well suited for the implementation of string  matching. A computational counterpart of the full logic is obtained from relational algebra by extending the selection operator into filters based on these multitape machines. Safety of formulas in alignment logic implies that new strings generated from old ones have to be of bounded length. While an undecidable property in general, this boundedness is decidable for an important subclass of formulas. As far as expressive power is concerned, alignment logic includes previous proposals for querying string databases, and gives full Turing computability. The language can be restricted to define exactly regular sets and sets in the polynomial hierarchy.},
booktitle = {Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems},
pages = {303–312},
numpages = {10},
location = {Minneapolis, Minnesota, USA},
series = {PODS '94}
}

