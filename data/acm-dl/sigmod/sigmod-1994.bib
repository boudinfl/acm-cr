@inproceedings{10.1145/191839.191844,
author = {Barbar\'{a}, Daniel and Imieli\'{n}ski, Tomasz},
title = {Sleepers and Workaholics: Caching Strategies in Mobile Environments},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191844},
doi = {10.1145/191839.191844},
abstract = {In the mobile wireless computing environment of the future a large number of users equipped with low powered palm-top machines will query databases over the wireless communication channels. Palmtop based units will often be disconnected for prolonged periods of time due to the battery power saving measures; palmtops will also frequencly relocate between different cells and connect to different data servers at different times. Caching of frequently accessed data items will be an important technique that will reduce contention on the narrow bandwidth wireless channel. However, cache invalidation strategies will be severely affected by the disconnection and mobility of the clients. The server may no longer know which clients are currently residing under its cell and which of them are   currently on. We propose a taxonomy of different cache invalidation strategies and study the impact of client's disconnection times on their performance. We determine that for the units which are often disconnected (sleepers) the best cache invalidation strategy is based on signatures previously used for efficient file comparison. On the other hand, for units which are connected most of the time (workaholics), the best cache invalidation strategy is based on the periodic broadcast of changed data items.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {1–12},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191844,
author = {Barbar\'{a}, Daniel and Imieli\'{n}ski, Tomasz},
title = {Sleepers and Workaholics: Caching Strategies in Mobile Environments},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191844},
doi = {10.1145/191843.191844},
abstract = {In the mobile wireless computing environment of the future a large number of users equipped with low powered palm-top machines will query databases over the wireless communication channels. Palmtop based units will often be disconnected for prolonged periods of time due to the battery power saving measures; palmtops will also frequencly relocate between different cells and connect to different data servers at different times. Caching of frequently accessed data items will be an important technique that will reduce contention on the narrow bandwidth wireless channel. However, cache invalidation strategies will be severely affected by the disconnection and mobility of the clients. The server may no longer know which clients are currently residing under its cell and which of them are   currently on. We propose a taxonomy of different cache invalidation strategies and study the impact of client's disconnection times on their performance. We determine that for the units which are often disconnected (sleepers) the best cache invalidation strategy is based on signatures previously used for efficient file comparison. On the other hand, for units which are connected most of the time (workaholics), the best cache invalidation strategy is based on the periodic broadcast of changed data items.},
journal = {SIGMOD Rec.},
month = may,
pages = {1–12},
numpages = {12}
}

@inproceedings{10.1145/191839.191845,
author = {Huang, Yixiu and Sistla, Prasad and Wolfson, Ouri},
title = {Data Replication for Mobile Computers},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191845},
doi = {10.1145/191839.191845},
abstract = {Users of mobile computers will soon have online access to a large number of databases via wireless networks. Because of limited bandwidth, wireless communication is more expensive than wire communication. In this paper we present and analyze various static and dynamic data allocation methods. The objective is to optimize the communication cost between a mobile computer and the stationary computer that stores the online database. Analysis is performed in two cost models. One is connection (or time) based, as in cellular telephones, where the user is charged per minute of connection. The other is message based, as in packet radio networks, where the user is charged per message. Our analysis addresses both, the average case and the worst case for determining the best allocation method.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {13–24},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191845,
author = {Huang, Yixiu and Sistla, Prasad and Wolfson, Ouri},
title = {Data Replication for Mobile Computers},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191845},
doi = {10.1145/191843.191845},
abstract = {Users of mobile computers will soon have online access to a large number of databases via wireless networks. Because of limited bandwidth, wireless communication is more expensive than wire communication. In this paper we present and analyze various static and dynamic data allocation methods. The objective is to optimize the communication cost between a mobile computer and the stationary computer that stores the online database. Analysis is performed in two cost models. One is connection (or time) based, as in cellular telephones, where the user is charged per minute of connection. The other is message based, as in packet radio networks, where the user is charged per message. Our analysis addresses both, the average case and the worst case for determining the best allocation method.},
journal = {SIGMOD Rec.},
month = may,
pages = {13–24},
numpages = {12}
}

@inproceedings{10.1145/191839.191846,
author = {Imielinski, Tomasz and Viswanathan, S. and Badrinath, B. R.},
title = {Energy Efficient Indexing on Air},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191846},
doi = {10.1145/191839.191846},
abstract = {We consider wireless broadcasting of data as a way of disseminating information to a massive number of users. Organizing and accessing information on wireless communication channels is different from the problem of organizing and accessing data on the disk. We describe two methods, (1,m) Indexing and Distributed Indexing, for organizing and accessing broadcast data. We demonstrate that the proposed algorithms lead to significant improvement of battery life, while retaining a low access time.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {25–36},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191846,
author = {Imielinski, Tomasz and Viswanathan, S. and Badrinath, B. R.},
title = {Energy Efficient Indexing on Air},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191846},
doi = {10.1145/191843.191846},
abstract = {We consider wireless broadcasting of data as a way of disseminating information to a massive number of users. Organizing and accessing information on wireless communication channels is different from the problem of organizing and accessing data on the disk. We describe two methods, (1,m) Indexing and Distributed Indexing, for organizing and accessing broadcast data. We demonstrate that the proposed algorithms lead to significant improvement of battery life, while retaining a low access time.},
journal = {SIGMOD Rec.},
month = may,
pages = {25–36},
numpages = {12}
}

@inproceedings{10.1145/191839.191847,
author = {Ahn, Ilsoo},
title = {SIGMOD Challenges Paper: Database Issues in Telecommunications Network Management},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191847},
doi = {10.1145/191839.191847},
abstract = {Various types of computer systems are used behind the scenes in many parts of the telecommunications network to ensure its efficient and trouble-free operation. These systems are large, complex, and expensive real-time computer systems that are mission critical, and contains a database engine as a critical component. These systems share some of common database issues with conventional applications, but they also exhibit rather unique characteristics that present challenging database issues. Major DBMS issues for network management include choosing the right data model, handling two different kinds of data in terms of integrity and recovery constraints, supporting temporal queries, satisfying real-time performance and high availability requirements, and several miscellaneous issues. Some of these issues have been investigated in various areas of database researches, but most of them largely remain in the research stage. Advances in these areas that result in actual integrated implementations for data-intensive, real-time and temporal applications are eagerly awaited.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {37–43},
numpages = {7},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191847,
author = {Ahn, Ilsoo},
title = {SIGMOD Challenges Paper: Database Issues in Telecommunications Network Management},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191847},
doi = {10.1145/191843.191847},
abstract = {Various types of computer systems are used behind the scenes in many parts of the telecommunications network to ensure its efficient and trouble-free operation. These systems are large, complex, and expensive real-time computer systems that are mission critical, and contains a database engine as a critical component. These systems share some of common database issues with conventional applications, but they also exhibit rather unique characteristics that present challenging database issues. Major DBMS issues for network management include choosing the right data model, handling two different kinds of data in terms of integrity and recovery constraints, supporting temporal queries, satisfying real-time performance and high availability requirements, and several miscellaneous issues. Some of these issues have been investigated in various areas of database researches, but most of them largely remain in the research stage. Advances in these areas that result in actual integrated implementations for data-intensive, real-time and temporal applications are eagerly awaited.},
journal = {SIGMOD Rec.},
month = may,
pages = {37–43},
numpages = {7}
}

@inproceedings{10.1145/191839.191848,
author = {Biliris, A. and Dar, S. and Gehani, N. and Jagadish, H. V. and Ramamritham, K.},
title = {ASSET: A System for Supporting Extended Transactions},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191848},
doi = {10.1145/191839.191848},
abstract = {Extended transaction models in databases were motivated by the needs of complex applications such as CAD and software engineering. Transactions in such applications have diverse needs, for example, they may be long lived and they may need to cooperate. We describe ASSET, a system for supporting extended transactions. ASSET consists of a set of transaction primitives that allow users to define custom transaction semantics to match the needs of specific applications. We show how the transaction primitives can be used to specify a variety of transaction models, including nested transactions, split transactions, and sagas. Application-specific transaction models with relaxed correctness criteria, and computations involving workflows, can also be specified using the primitives. We describe the implementation of the ASSET primitives in the context of the Ode database.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {44–54},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191848,
author = {Biliris, A. and Dar, S. and Gehani, N. and Jagadish, H. V. and Ramamritham, K.},
title = {ASSET: A System for Supporting Extended Transactions},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191848},
doi = {10.1145/191843.191848},
abstract = {Extended transaction models in databases were motivated by the needs of complex applications such as CAD and software engineering. Transactions in such applications have diverse needs, for example, they may be long lived and they may need to cooperate. We describe ASSET, a system for supporting extended transactions. ASSET consists of a set of transaction primitives that allow users to define custom transaction semantics to match the needs of specific applications. We show how the transaction primitives can be used to specify a variety of transaction models, including nested transactions, split transactions, and sagas. Application-specific transaction models with relaxed correctness criteria, and computations involving workflows, can also be specified using the primitives. We describe the implementation of the ASSET primitives in the context of the Ode database.},
journal = {SIGMOD Rec.},
month = may,
pages = {44–54},
numpages = {11}
}

@inproceedings{10.1145/191839.191849,
author = {Mohan, C. and Narang, Inderpal},
title = {ARIES/CSA: A Method for Database Recovery in Client-Server Architectures},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191849},
doi = {10.1145/191839.191849},
abstract = {This paper presents an algorithm, called ARIES/CSA (Algorithm for Recovery and Isolation Exploiting Semantics for Client-Server Architectures), for performing recovery correctly in client-server (CS) architectures. In CS, the server manages the disk version of the database. The clients, after obtaining database pages from the server, cache them in their buffer pools. Clients perform their updates on the cached pages and produce log records. The log records are buffered locally in virtual storage and later sent to the single log at the server. ARIES/CSA supports a write-ahead logging (WAL), fine-granularity (e.g., record) locking, partial rollbacks and flexible buffer management policies like steal and no-force. It does not require   that the clocks on the clients and the server be synchronized. Checkpointing by the server and the clients allows for flexible and easier recovery.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {55–66},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191849,
author = {Mohan, C. and Narang, Inderpal},
title = {ARIES/CSA: A Method for Database Recovery in Client-Server Architectures},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191849},
doi = {10.1145/191843.191849},
abstract = {This paper presents an algorithm, called ARIES/CSA (Algorithm for Recovery and Isolation Exploiting Semantics for Client-Server Architectures), for performing recovery correctly in client-server (CS) architectures. In CS, the server manages the disk version of the database. The clients, after obtaining database pages from the server, cache them in their buffer pools. Clients perform their updates on the cached pages and produce log records. The log records are buffered locally in virtual storage and later sent to the single log at the server. ARIES/CSA supports a write-ahead logging (WAL), fine-granularity (e.g., record) locking, partial rollbacks and flexible buffer management policies like steal and no-force. It does not require   that the clocks on the clients and the server be synchronized. Checkpointing by the server and the clients allows for flexible and easier recovery.},
journal = {SIGMOD Rec.},
month = may,
pages = {55–66},
numpages = {12}
}

@inproceedings{10.1145/191839.191850,
author = {Zhang, Aidong and Nodine, Marian and Bhargava, Bharat and Bukhres, Omran},
title = {Ensuring Relaxed Atomicity for Flexible Transactions in Multidatabase Systems},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191850},
doi = {10.1145/191839.191850},
abstract = {Global transaction management requires cooperation from local sites to ensure the consistent and reliable execution of global transactions in a distributed database system. In a heterogeneous distributed database (or multidatabase) environment, various local sites make conflicting assertions of autonomy over the execution of global transactions. A flexible transaction model for the specification of global transactions makes it possible to deal robustly with these conflicting requirements. This paper presents an approach that preserves the semi-atomicity (a weaker form of atomicity) of flexible transactions, allowing local sites to autonomously maintain serializability and recoverability. We offer a fundamental characterization of the flexible transaction model and precisely define the semi-atomicity. We investigate the commit dependencies among the subtransactions of a flexible transaction. These dependencies are used to control the commitment order of the subtransactions. We next identify those restrictions that must be placed upon a flexible transaction to ensure the maintenance of its semi-atomicity. As atomicity is a restrictive criterion, semi-atomicity enhances the class of executable global transactions.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {67–78},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191850,
author = {Zhang, Aidong and Nodine, Marian and Bhargava, Bharat and Bukhres, Omran},
title = {Ensuring Relaxed Atomicity for Flexible Transactions in Multidatabase Systems},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191850},
doi = {10.1145/191843.191850},
abstract = {Global transaction management requires cooperation from local sites to ensure the consistent and reliable execution of global transactions in a distributed database system. In a heterogeneous distributed database (or multidatabase) environment, various local sites make conflicting assertions of autonomy over the execution of global transactions. A flexible transaction model for the specification of global transactions makes it possible to deal robustly with these conflicting requirements. This paper presents an approach that preserves the semi-atomicity (a weaker form of atomicity) of flexible transactions, allowing local sites to autonomously maintain serializability and recoverability. We offer a fundamental characterization of the flexible transaction model and precisely define the semi-atomicity. We investigate the commit dependencies among the subtransactions of a flexible transaction. These dependencies are used to control the commitment order of the subtransactions. We next identify those restrictions that must be placed upon a flexible transaction to ensure the maintenance of its semi-atomicity. As atomicity is a restrictive criterion, semi-atomicity enhances the class of executable global transactions.},
journal = {SIGMOD Rec.},
month = may,
pages = {67–78},
numpages = {12}
}

@inbook{10.1145/191839.191852,
author = {Berson, Steven and Ghandeharizadeh, Shahram and Muntz, Richard and Ju, Xiangyu},
title = {Staggered Striping in Multimedia Information Systems},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191852},
abstract = {Multimedia information systems have emerged as an essential component of many application domains ranging from library information systems to entertainment technology. However, most implementations of these systems cannot support the continuous display of multimedia objects and suffer from frequent disruptions and delays termed hiccups. This is due to the low I/O bandwidth of the current disk technology, the high bandwidth requirement of multimedia objects, and the large size of these objects that almost always requires them to be disk resident. One approach to resolve this limitation is to decluster a multimedia object across multiple disk drives in order to employ the aggregate bandwidth of several disks to support the continuous retrieval (and display) of objects.  This paper describes staggered striping as a novel technique to provide effective support for multiple users accessing the different objects in the database. Detailed simulations confirm the superiority of staggered striping.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {79–90},
numpages = {12}
}

@article{10.1145/191843.191852,
author = {Berson, Steven and Ghandeharizadeh, Shahram and Muntz, Richard and Ju, Xiangyu},
title = {Staggered Striping in Multimedia Information Systems},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191852},
doi = {10.1145/191843.191852},
abstract = {Multimedia information systems have emerged as an essential component of many application domains ranging from library information systems to entertainment technology. However, most implementations of these systems cannot support the continuous display of multimedia objects and suffer from frequent disruptions and delays termed hiccups. This is due to the low I/O bandwidth of the current disk technology, the high bandwidth requirement of multimedia objects, and the large size of these objects that almost always requires them to be disk resident. One approach to resolve this limitation is to decluster a multimedia object across multiple disk drives in order to employ the aggregate bandwidth of several disks to support the continuous retrieval (and display) of objects.  This paper describes staggered striping as a novel technique to provide effective support for multiple users accessing the different objects in the database. Detailed simulations confirm the superiority of staggered striping.},
journal = {SIGMOD Rec.},
month = may,
pages = {79–90},
numpages = {12}
}

@inproceedings{10.1145/191839.191856,
author = {Gibbs, Simon and Breiteneder, Christian and Tsichritzis, Dennis},
title = {Data Modeling of Time-Based Media},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191856},
doi = {10.1145/191839.191856},
abstract = {Many aspects of time-based media—complex data encoding, compression, “quality factors,” timing—appear problematic from a data modeling standpoint. This paper proposes timed streams as the basic abstraction for modeling time-based media. Several media-independent structuring mechanisms are introduced and a data model is presented which, rather than leaving the interpretation of multimedia data to applications, addresses the complex organization and relationships present in multimedia.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {91–102},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191856,
author = {Gibbs, Simon and Breiteneder, Christian and Tsichritzis, Dennis},
title = {Data Modeling of Time-Based Media},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191856},
doi = {10.1145/191843.191856},
abstract = {Many aspects of time-based media—complex data encoding, compression, “quality factors,” timing—appear problematic from a data modeling standpoint. This paper proposes timed streams as the basic abstraction for modeling time-based media. Several media-independent structuring mechanisms are introduced and a data model is presented which, rather than leaving the interpretation of multimedia data to applications, addresses the complex organization and relationships present in multimedia.},
journal = {SIGMOD Rec.},
month = may,
pages = {91–102},
numpages = {12}
}

@inproceedings{10.1145/191839.191860,
author = {Mumick, Inderpal Singh and Pirahesh, Hamid},
title = {Implementation of Magic-Sets in a Relational Database System},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191860},
doi = {10.1145/191839.191860},
abstract = {We describe the implementation of the magic-sets transformation in the Starburst extensible relational database system. To our knowledge this is the first implementation of the magic-sets transformation in a relational database system. The Starburst implementation has many novel features that make our implementation especially interesting to database practitioners (in addition to database researchers). (1) We use a cost-based heuristic for determining join orders (sips) before applying magic. (2) We push all equality and non-equality predicates using magic, replacing traditional predicate pushdown optimizations. (3) We apply magic to full SQL with duplicates, aggregation, null values, and subqueries. (4) We integrate magic with other relational optimization techniques. (5) The implementation is extensible.Our implementation demonstrates the feasibility of the magic-sets transformation for commercial relational systems, and provides a mechanism to implement magic as an integral part of a new database system, or as an add-on to an existing database system.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {103–114},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191860,
author = {Mumick, Inderpal Singh and Pirahesh, Hamid},
title = {Implementation of Magic-Sets in a Relational Database System},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191860},
doi = {10.1145/191843.191860},
abstract = {We describe the implementation of the magic-sets transformation in the Starburst extensible relational database system. To our knowledge this is the first implementation of the magic-sets transformation in a relational database system. The Starburst implementation has many novel features that make our implementation especially interesting to database practitioners (in addition to database researchers). (1) We use a cost-based heuristic for determining join orders (sips) before applying magic. (2) We push all equality and non-equality predicates using magic, replacing traditional predicate pushdown optimizations. (3) We apply magic to full SQL with duplicates, aggregation, null values, and subqueries. (4) We integrate magic with other relational optimization techniques. (5) The implementation is extensible.Our implementation demonstrates the feasibility of the magic-sets transformation for commercial relational systems, and provides a mechanism to implement magic as an integral part of a new database system, or as an add-on to an existing database system.},
journal = {SIGMOD Rec.},
month = may,
pages = {103–114},
numpages = {12}
}

@inproceedings{10.1145/191839.191863,
author = {Wang, Jason Tsong-Li and Chirn, Gung-Wei and Marr, Thomas G. and Shapiro, Bruce and Shasha, Dennis and Zhang, Kaizhong},
title = {Combinatorial Pattern Discovery for Scientific Data: Some Preliminary Results},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191863},
doi = {10.1145/191839.191863},
abstract = {Suppose you are given a set of natural entities (e.g., proteins, organisms, weather patterns, etc.) that possess some important common externally observable properties. You also have a structural description of the entities (e.g., sequence, topological, or geometrical data) and a distance metric. Combinatorial pattern discovery is the activity of finding patterns in the structural data that might explain these common properties based on the metric.This paper presents an example of combinatorial pattern discovery: the discovery of patterns in protein databases. The structural representation we consider are strings and the distance metric is string edit distance permitting variable length don't cares. Our techniques incorporate string matching algorithms and novel heuristics for discovery and optimization, most of which generalize to other combinatorial structures. Experimental results of applying the techniques to both generated data and functionally related protein families obtained from the Cold Spring Harbor Laboratory show the effectiveness of the proposed techniques. When we apply the discovered patterns to perform protein classification, they give information that is complementary to the best protein classifier available today.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {115–125},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191863,
author = {Wang, Jason Tsong-Li and Chirn, Gung-Wei and Marr, Thomas G. and Shapiro, Bruce and Shasha, Dennis and Zhang, Kaizhong},
title = {Combinatorial Pattern Discovery for Scientific Data: Some Preliminary Results},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191863},
doi = {10.1145/191843.191863},
abstract = {Suppose you are given a set of natural entities (e.g., proteins, organisms, weather patterns, etc.) that possess some important common externally observable properties. You also have a structural description of the entities (e.g., sequence, topological, or geometrical data) and a distance metric. Combinatorial pattern discovery is the activity of finding patterns in the structural data that might explain these common properties based on the metric.This paper presents an example of combinatorial pattern discovery: the discovery of patterns in protein databases. The structural representation we consider are strings and the distance metric is string edit distance permitting variable length don't cares. Our techniques incorporate string matching algorithms and novel heuristics for discovery and optimization, most of which generalize to other combinatorial structures. Experimental results of applying the techniques to both generated data and functionally related protein families obtained from the Cold Spring Harbor Laboratory show the effectiveness of the proposed techniques. When we apply the discovered patterns to perform protein classification, they give information that is complementary to the best protein classifier available today.},
journal = {SIGMOD Rec.},
month = may,
pages = {115–125},
numpages = {11}
}

@inproceedings{10.1145/191839.191869,
author = {Gravano, Luis and Garc\'{\i}a-Molina, H\'{e}ctor and Tomasic, Anthony},
title = {The Effectiveness of GIOSS for the Text Database Discovery Problem},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191869},
doi = {10.1145/191839.191869},
abstract = {The popularity of on-line document databases has led to a new problem: finding which text databases (out of many candidate choices) are the most relevant to a user. Identifying the relevant databases for a given query is the text database discovery problem. The first part of this paper presents a practical solution based on estimating the result size of a query and a database. The method is termed GlOSS—Glossary of Servers Server. The second part of this paper evaluates the effectiveness of GlOSS based on a trace of real user queries. In addition, we analyze the storage cost of our approach.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {126–137},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191869,
author = {Gravano, Luis and Garc\'{\i}a-Molina, H\'{e}ctor and Tomasic, Anthony},
title = {The Effectiveness of GIOSS for the Text Database Discovery Problem},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191869},
doi = {10.1145/191843.191869},
abstract = {The popularity of on-line document databases has led to a new problem: finding which text databases (out of many candidate choices) are the most relevant to a user. Identifying the relevant databases for a given query is the text database discovery problem. The first part of this paper presents a practical solution based on estimating the result size of a query and a database. The method is termed GlOSS—Glossary of Servers Server. The second part of this paper evaluates the effectiveness of GlOSS based on a trace of real user queries. In addition, we analyze the storage cost of our approach.},
journal = {SIGMOD Rec.},
month = may,
pages = {126–137},
numpages = {12}
}

@inproceedings{10.1145/191839.191870,
author = {Ioannidis, Yannis E. and Lashkari, Yezdi},
title = {Incomplete Path Expressions and Their Disambiguation},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191870},
doi = {10.1145/191839.191870},
abstract = {When we, humans, talk to each other we have no trouble disambiguating what another person means, although our statements are almost never meticulously specified down to very last detail. We “fill in the gaps” using our common-sense knowledge about the world. We present a powerful mechanism that allows users of object-oriented database systems to specify certain types of ad-hoc queries in a manner closer to the way we pose questions to each other. Specifically, the system accepts as input queries with incomplete, and therefore ambiguous, path expressions. From them, it generates queries with fully-specified path expressions that are consistent with those given as input and capture what the user most likely meant by them. This is achieved by mapping the problem of path expression disambiguation to an optimal path computation (in the transitive closure sense) over a directed graph that represents the schema. Our method works by exploiting the semantics of the kinds of relationships in the schema and requires no special knowledge about the contents of the underlying database, i.e., it is domain independent. In a limited set of experiments with human subjects, the proposed mechanism was very successful in disambiguating incomplete path expressions.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {138–149},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191870,
author = {Ioannidis, Yannis E. and Lashkari, Yezdi},
title = {Incomplete Path Expressions and Their Disambiguation},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191870},
doi = {10.1145/191843.191870},
abstract = {When we, humans, talk to each other we have no trouble disambiguating what another person means, although our statements are almost never meticulously specified down to very last detail. We “fill in the gaps” using our common-sense knowledge about the world. We present a powerful mechanism that allows users of object-oriented database systems to specify certain types of ad-hoc queries in a manner closer to the way we pose questions to each other. Specifically, the system accepts as input queries with incomplete, and therefore ambiguous, path expressions. From them, it generates queries with fully-specified path expressions that are consistent with those given as input and capture what the user most likely meant by them. This is achieved by mapping the problem of path expression disambiguation to an optimal path computation (in the transitive closure sense) over a directed graph that represents the schema. Our method works by exploiting the semantics of the kinds of relationships in the schema and requires no special knowledge about the contents of the underlying database, i.e., it is domain independent. In a limited set of experiments with human subjects, the proposed mechanism was very successful in disambiguating incomplete path expressions.},
journal = {SIGMOD Rec.},
month = may,
pages = {138–149},
numpages = {12}
}

@inproceedings{10.1145/191839.191872,
author = {Cole, Richard L. and Graefe, Goetz},
title = {Optimization of Dynamic Query Evaluation Plans},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191872},
doi = {10.1145/191839.191872},
abstract = {Traditional query optimizers assume accurate knowledge of run-time parameters such as selectivities and resource availability during plan optimization, i.e., at compile time. In reality, however, this assumption is often not justified. Therefore, the “static” plans produced by traditional optimizers may not be optimal for many of their actual run-time invocations. Instead, we propose a novel optimization model that assigns the bulk of the optimization effort to compile-time and delays carefully selected optimization decisions until run-time. Our previous work defined the run-time primitives, “dynamic plans” using “choose-plan” operators, for executing such delayed decisions, but did not solve the problem of constructing dynamic plans at compile-time. The present paper introduces techniques that solve this problem. Experience with a working prototype optimizer demonstrates (i) that the additional optimization and start-up overhead of dynamic plans compared to static plans is dominated by their advantage at run-time, (ii) that dynamic plans are as robust as the “brute-force” remedy of run-time optimization, i.e., dynamic plans maintain their optimality even if parameters change between compile-time and run-time, and (iii) that the start-up overhead of dynamic plans is significantly less than the time required for complete optimization at run-time. In other words, our proposed techniques are superior to both techniques considered to-date, namely compile-time optimization into a single static plan as well as run-time optimization. Finally, we believe that the concepts and technology described can be transferred to commercial query optimizers in order to improve the performance of embedded queries with host variables in the query predicate and to adapt to run-time system loads unpredictable at compile time.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {150–160},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191872,
author = {Cole, Richard L. and Graefe, Goetz},
title = {Optimization of Dynamic Query Evaluation Plans},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191872},
doi = {10.1145/191843.191872},
abstract = {Traditional query optimizers assume accurate knowledge of run-time parameters such as selectivities and resource availability during plan optimization, i.e., at compile time. In reality, however, this assumption is often not justified. Therefore, the “static” plans produced by traditional optimizers may not be optimal for many of their actual run-time invocations. Instead, we propose a novel optimization model that assigns the bulk of the optimization effort to compile-time and delays carefully selected optimization decisions until run-time. Our previous work defined the run-time primitives, “dynamic plans” using “choose-plan” operators, for executing such delayed decisions, but did not solve the problem of constructing dynamic plans at compile-time. The present paper introduces techniques that solve this problem. Experience with a working prototype optimizer demonstrates (i) that the additional optimization and start-up overhead of dynamic plans compared to static plans is dominated by their advantage at run-time, (ii) that dynamic plans are as robust as the “brute-force” remedy of run-time optimization, i.e., dynamic plans maintain their optimality even if parameters change between compile-time and run-time, and (iii) that the start-up overhead of dynamic plans is significantly less than the time required for complete optimization at run-time. In other words, our proposed techniques are superior to both techniques considered to-date, namely compile-time optimization into a single static plan as well as run-time optimization. Finally, we believe that the concepts and technology described can be transferred to commercial query optimizers in order to improve the performance of embedded queries with host variables in the query predicate and to adapt to run-time system loads unpredictable at compile time.},
journal = {SIGMOD Rec.},
month = may,
pages = {150–160},
numpages = {11}
}

@inproceedings{10.1145/191839.191874,
author = {Chen, Chungmin Melvin and Roussopoulos, Nick},
title = {Adaptive Selectivity Estimation Using Query Feedback},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191874},
doi = {10.1145/191839.191874},
abstract = {In this paper, we propose a novel approach for estimating the record selectivities of database queries. The real attribute value distribution is adaptively approximated by a curve-fitting function using a query feedback mechanism. This approach has the advantage of requiring no extra database access overhead for gathering statistics and of being able to continuously adapt the value distribution through queries and updates. Experimental results show that the estimation accuracy of this approach is comparable to traditional methods based on statistics gathering.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {161–172},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191874,
author = {Chen, Chungmin Melvin and Roussopoulos, Nick},
title = {Adaptive Selectivity Estimation Using Query Feedback},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191874},
doi = {10.1145/191843.191874},
abstract = {In this paper, we propose a novel approach for estimating the record selectivities of database queries. The real attribute value distribution is adaptively approximated by a curve-fitting function using a query feedback mechanism. This approach has the advantage of requiring no extra database access overhead for gathering statistics and of being able to continuously adapt the value distribution through queries and updates. Experimental results show that the estimation accuracy of this approach is comparable to traditional methods based on statistics gathering.},
journal = {SIGMOD Rec.},
month = may,
pages = {161–172},
numpages = {12}
}

@inproceedings{10.1145/191839.191877,
author = {Swami, Arun and Schiefer, K. Bernhard},
title = {Estimating Page Fetches for Index Scans with Finite LRU Buffers},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191877},
doi = {10.1145/191839.191877},
abstract = {We describe an algorithm for estimating the number of page fetches for a partial or complete scan of a B-tree index. The algorithm obtains estimates for the number of page fetches for an index scan when given the number of tuples selected and the number of LRU buffers currently available. The algorithm has an initial phase that is performed exactly once before any estimates are calculated. This initial phase, involving LRU buffer modeling, requires a scan of all the index entries and calculates the number of page fetches for different buffer sizes. An approximate empirical model is obtained from this data. Subsequently, an inexpensive estimation procedure is called by the query optimizer whenever it needs an estimate of the page fetches for the index scan. This procedure utilizes the empirical model obtained in the initial phase.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {173–184},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191877,
author = {Swami, Arun and Schiefer, K. Bernhard},
title = {Estimating Page Fetches for Index Scans with Finite LRU Buffers},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191877},
doi = {10.1145/191843.191877},
abstract = {We describe an algorithm for estimating the number of page fetches for a partial or complete scan of a B-tree index. The algorithm obtains estimates for the number of page fetches for an index scan when given the number of tuples selected and the number of LRU buffers currently available. The algorithm has an initial phase that is performed exactly once before any estimates are calculated. This initial phase, involving LRU buffer modeling, requires a scan of all the index entries and calculates the number of page fetches for different buffer sizes. An approximate empirical model is obtained from this data. Subsequently, an inexpensive estimation procedure is called by the query optimizer whenever it needs an estimate of the page fetches for the index scan. This procedure utilizes the empirical model obtained in the initial phase.},
journal = {SIGMOD Rec.},
month = may,
pages = {173–184},
numpages = {12}
}

@inproceedings{10.1145/191839.191879,
author = {Hsiao, Hui-I and Chen, Ming-Syan and Yu, Philip S.},
title = {On Parallel Execution of Multiple Pipelined Hash Joins},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191879},
doi = {10.1145/191839.191879},
abstract = {In this paper we study parallel execution of multiple pipelined hash joins. Specifically, we deal with two issues, processor allocation and the use of hash filters, to improve parallel execution of hash joins. We first present a scheme to transform a bushy execution tree to an allocation tree, where each node denotes a pipeline. Then, processors are allocated to the nodes in the allocation tree based on the concept of synchronous execution time such that inner relations (i.e., hash tables) in a pipeline can be made available approximately the same time. In addition, the approach of hash filtering is investigated to further improve the overall performance. Performance studies are conducted via simulation to demonstrate the importance of processor allocation and to evaluate various schemes using hash filters. Simulation results indicate that processor allocation based on the allocation tree significantly outperforms that based on the original bushy tree, and that the effect of hash filtering becomes prominent as the number of relations in a query increases.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {185–196},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191879,
author = {Hsiao, Hui-I and Chen, Ming-Syan and Yu, Philip S.},
title = {On Parallel Execution of Multiple Pipelined Hash Joins},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191879},
doi = {10.1145/191843.191879},
abstract = {In this paper we study parallel execution of multiple pipelined hash joins. Specifically, we deal with two issues, processor allocation and the use of hash filters, to improve parallel execution of hash joins. We first present a scheme to transform a bushy execution tree to an allocation tree, where each node denotes a pipeline. Then, processors are allocated to the nodes in the allocation tree based on the concept of synchronous execution time such that inner relations (i.e., hash tables) in a pipeline can be made available approximately the same time. In addition, the approach of hash filtering is investigated to further improve the overall performance. Performance studies are conducted via simulation to demonstrate the importance of processor allocation and to evaluate various schemes using hash filters. Simulation results indicate that processor allocation based on the allocation tree significantly outperforms that based on the original bushy tree, and that the effect of hash filtering becomes prominent as the number of relations in a query increases.},
journal = {SIGMOD Rec.},
month = may,
pages = {185–196},
numpages = {12}
}

@inproceedings{10.1145/191839.191880,
author = {Brinkhoff, Thomas and Kriegel, Hans-Peter and Schneider, Ralf and Seeger, Bernhard},
title = {Multi-Step Processing of Spatial Joins},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191880},
doi = {10.1145/191839.191880},
abstract = {Spatial joins are one of the most important operations for combining spatial objects of several relations. In this paper, spatial join processing is studied in detail for extended spatial objects in two-dimensional data space. We present an approach for spatial join processing that is based on three steps. First, a spatial join is performed on the minimum bounding rectangles of the objects returning a set of candidates. Various approaches for accelerating this step of join processing have been examined at the last year's conference [BKS 93a]. In this paper, we focus on the problem how to compute the answers from the set of candidate which is handled by the following two steps. First of all, sophisticated approximations are used to identify answers as well as to filter out false hits  from the set of candidates. For this purpose, we investigate various types of conservative and progressive approximations. In the last step, the exact geometry of the remaining candidates has to be tested against the join predicate. The time required for computing spatial join predicates can essentially be reduced when objects are adequately organized in main memory. In our approach, objects are first decomposed into simple components which are exclusively organized by a main-memory resident spatial data structure. Overall, we present a complete approach of spatial join processing on complex spatial objects. The performance of the individual steps of our approach is evaluated with data sets from real cartographic applications. The results show that our approach reduces the total execution  time of the spatial join by factors.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {197–208},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191880,
author = {Brinkhoff, Thomas and Kriegel, Hans-Peter and Schneider, Ralf and Seeger, Bernhard},
title = {Multi-Step Processing of Spatial Joins},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191880},
doi = {10.1145/191843.191880},
abstract = {Spatial joins are one of the most important operations for combining spatial objects of several relations. In this paper, spatial join processing is studied in detail for extended spatial objects in two-dimensional data space. We present an approach for spatial join processing that is based on three steps. First, a spatial join is performed on the minimum bounding rectangles of the objects returning a set of candidates. Various approaches for accelerating this step of join processing have been examined at the last year's conference [BKS 93a]. In this paper, we focus on the problem how to compute the answers from the set of candidate which is handled by the following two steps. First of all, sophisticated approximations are used to identify answers as well as to filter out false hits  from the set of candidates. For this purpose, we investigate various types of conservative and progressive approximations. In the last step, the exact geometry of the remaining candidates has to be tested against the join predicate. The time required for computing spatial join predicates can essentially be reduced when objects are adequately organized in main memory. In our approach, objects are first decomposed into simple components which are exclusively organized by a main-memory resident spatial data structure. Overall, we present a complete approach of spatial join processing on complex spatial objects. The performance of the individual steps of our approach is evaluated with data sets from real cartographic applications. The results show that our approach reduces the total execution  time of the spatial join by factors.},
journal = {SIGMOD Rec.},
month = may,
pages = {197–208},
numpages = {12}
}

@inproceedings{10.1145/191839.191881,
author = {Lo, Ming-Ling and Ravishankar, Chinya V.},
title = {Spatial Joins Using Seeded Trees},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191881},
doi = {10.1145/191839.191881},
abstract = {Existing methods for spatial joins assume the existence of indices for the participating data sets. This assumption is not realistic for applications involving multiple map layer overlays or for queries involving non-spatial selections. In this paper, we explore a spatial join method that dynamically constructs index trees called seeded trees at join time. This methods uses knowledge of the data sets involved in the join process.Seeded trees are R-tree like structures, and are divided into the seed levels and the grown levels. The nodes in the seed levels are used to guide tree growth during tree construction. The seed levels can also be used to filter out some input data during construction, thereby reducing tree size. We  develop a technique that uses intermediate linked lists during tree construction and significantly speeds up the tree construction process. The technique allows a large number of random disk accesses during tree construction to be replaced by smaller numbers of sequential accesses.Our performance studies show that spatial joins using seeded trees outperform those using other methods significantly in terms of disk I/O. The CPU penalties incurred are also lower except when seed-level filtering is used.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {209–220},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191881,
author = {Lo, Ming-Ling and Ravishankar, Chinya V.},
title = {Spatial Joins Using Seeded Trees},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191881},
doi = {10.1145/191843.191881},
abstract = {Existing methods for spatial joins assume the existence of indices for the participating data sets. This assumption is not realistic for applications involving multiple map layer overlays or for queries involving non-spatial selections. In this paper, we explore a spatial join method that dynamically constructs index trees called seeded trees at join time. This methods uses knowledge of the data sets involved in the join process.Seeded trees are R-tree like structures, and are divided into the seed levels and the grown levels. The nodes in the seed levels are used to guide tree growth during tree construction. The seed levels can also be used to filter out some input data during construction, thereby reducing tree size. We  develop a technique that uses intermediate linked lists during tree construction and significantly speeds up the tree construction process. The technique allows a large number of random disk accesses during tree construction to be replaced by smaller numbers of sequential accesses.Our performance studies show that spatial joins using seeded trees outperform those using other methods significantly in terms of disk I/O. The CPU penalties incurred are also lower except when seed-level filtering is used.},
journal = {SIGMOD Rec.},
month = may,
pages = {209–220},
numpages = {12}
}

@inproceedings{10.1145/191839.191882,
author = {Pang, Hwee Hwa and Carey, Michael J. and Livny, Miron},
title = {Managing Memory for Real-Time Queries},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191882},
doi = {10.1145/191839.191882},
abstract = {The demanding performance objectives that real-time database systems (RTDBS) face necessitate the use of priority resource scheduling. This paper introduces a Priority Memory Management (PMM) algorithm that is designed to schedule queries in RTDBS. PMM attempts to minimize the number of missed deadlines by adapting both its multiprogramming level and its memory allocation strategy to the characteristics of the offered workload. A series of simulation experiments confirms that PMM's admission control and memory allocation mechanisms are very effective for real-time query scheduling.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {221–232},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191882,
author = {Pang, Hwee Hwa and Carey, Michael J. and Livny, Miron},
title = {Managing Memory for Real-Time Queries},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191882},
doi = {10.1145/191843.191882},
abstract = {The demanding performance objectives that real-time database systems (RTDBS) face necessitate the use of priority resource scheduling. This paper introduces a Priority Memory Management (PMM) algorithm that is designed to schedule queries in RTDBS. PMM attempts to minimize the number of missed deadlines by adapting both its multiprogramming level and its memory allocation strategy to the characteristics of the offered workload. A series of simulation experiments confirms that PMM's admission control and memory allocation mechanisms are very effective for real-time query scheduling.},
journal = {SIGMOD Rec.},
month = may,
pages = {221–232},
numpages = {12}
}

@inproceedings{10.1145/191839.191884,
author = {Nyberg, Chris and Barclay, Tom and Cvetanovic, Zarka and Gray, Jim and Lomet, Dave},
title = {AlphaSort: A RISC Machine Sort},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191884},
doi = {10.1145/191839.191884},
abstract = {A new sort algorithm, called AlphaSort, demonstrates that commodity processors and disks can handle commercial batch workloads. Using Alpha AXP processors, commodity memory, and arrays of SCSI disks, AlphaSort runs the industry-standard sort benchmark in seven seconds. This beats the best published record on a 32-cpu 32-disk Hypercube by 8:1. On another benchmark, AlphaSort sorted more than a gigabyte in a minute.AlphaSort is a cache-sensitive memory-intensive sort algorithm. It uses file striping to get high disk bandwidth. It uses QuickSort to generate runs and uses replacement-selection to merge the runs. It uses shared memory multiprocessors to break the sort into subsort chores.Because startup times are becoming a significant part of the total time, we propose two new benchmarks: (1) Minutesort: how much can you sort in a minute, and (2) DollarSort: how much can you sort for a dollar.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {233–242},
numpages = {10},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191884,
author = {Nyberg, Chris and Barclay, Tom and Cvetanovic, Zarka and Gray, Jim and Lomet, Dave},
title = {AlphaSort: A RISC Machine Sort},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191884},
doi = {10.1145/191843.191884},
abstract = {A new sort algorithm, called AlphaSort, demonstrates that commodity processors and disks can handle commercial batch workloads. Using Alpha AXP processors, commodity memory, and arrays of SCSI disks, AlphaSort runs the industry-standard sort benchmark in seven seconds. This beats the best published record on a 32-cpu 32-disk Hypercube by 8:1. On another benchmark, AlphaSort sorted more than a gigabyte in a minute.AlphaSort is a cache-sensitive memory-intensive sort algorithm. It uses file striping to get high disk bandwidth. It uses QuickSort to generate runs and uses replacement-selection to merge the runs. It uses shared memory multiprocessors to break the sort into subsort chores.Because startup times are becoming a significant part of the total time, we propose two new benchmarks: (1) Minutesort: how much can you sort in a minute, and (2) DollarSort: how much can you sort for a dollar.},
journal = {SIGMOD Rec.},
month = may,
pages = {233–242},
numpages = {10}
}

@inproceedings{10.1145/191839.191886,
author = {Gray, Jim and Sundaresan, Prakash and Englert, Susanne and Baclawski, Ken and Weinberger, Peter J.},
title = {Quickly Generating Billion-Record Synthetic Databases},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191886},
doi = {10.1145/191839.191886},
abstract = {Evaluating database system performance often requires generating synthetic databases—ones having certain statistical properties but filled with dummy information. When evaluating different database designs, it is often necessary to generate several databases and evaluate each design. As database sizes grow to terabytes, generation often takes longer than evaluation. This paper presents several database generation techniques. In particular it discusses: (1) Parallelism to get generation speedup and scaleup. (2) Congruential generators to get dense unique uniform distributions. (3) Special-case discrete logarithms to generate indices concurrent to the base table generation. (4) Modification of (2) to get exponential, normal, and self-similar distributions.The discussion is  in terms of generating billion-record SQL databases using C programs running on a shared-nothing computer system consisting of a hundred processors, with a thousand discs. The ideas apply to smaller databases, but large databases present the more difficult problems.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {243–252},
numpages = {10},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191886,
author = {Gray, Jim and Sundaresan, Prakash and Englert, Susanne and Baclawski, Ken and Weinberger, Peter J.},
title = {Quickly Generating Billion-Record Synthetic Databases},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191886},
doi = {10.1145/191843.191886},
abstract = {Evaluating database system performance often requires generating synthetic databases—ones having certain statistical properties but filled with dummy information. When evaluating different database designs, it is often necessary to generate several databases and evaluate each design. As database sizes grow to terabytes, generation often takes longer than evaluation. This paper presents several database generation techniques. In particular it discusses: (1) Parallelism to get generation speedup and scaleup. (2) Congruential generators to get dense unique uniform distributions. (3) Special-case discrete logarithms to generate indices concurrent to the base table generation. (4) Modification of (2) to get exponential, normal, and self-similar distributions.The discussion is  in terms of generating billion-record SQL databases using C programs running on a shared-nothing computer system consisting of a hundred processors, with a thousand discs. The ideas apply to smaller databases, but large databases present the more difficult problems.},
journal = {SIGMOD Rec.},
month = may,
pages = {243–252},
numpages = {10}
}

@inproceedings{10.1145/191839.191889,
author = {Vingralek, Radek and Breitbart, Yuri and Weikum, Gerhard},
title = {Distributed File Organization with Scalable Cost/Performance},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191889},
doi = {10.1145/191839.191889},
abstract = {This paper presents a distributed file organization for record-structured, disk-resident files with key-based exact-match access. The file is organized into buckets that are spread across multiple servers, where a server may hold multiple buckets. Client requests are serviced by mapping keys onto buckets and looking up the corresponding server in an address table. Dynamic growth in terms of file size and access load is supported by bucket splits and migration onto other existing or newly acquired servers.The significant and challenging problem addressed here is how to achieve scalability so that both the file size and the client throughput can be scaled up by linearly increasing the number of servers and dynamically redistributing data. Unlike previous work with similar objectives, our data redistribution considers explicitly the cost/performance ratio of the system by aiming to minimize the number of servers that are acquired to provide the required performance. A new server is acquired only if the overall server utilization in the system does not drop below a specified threshold. Preliminary simulation results show that the goal of scalability with controlled cost/performance is indeed achieved to a large extent.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {253–264},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191889,
author = {Vingralek, Radek and Breitbart, Yuri and Weikum, Gerhard},
title = {Distributed File Organization with Scalable Cost/Performance},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191889},
doi = {10.1145/191843.191889},
abstract = {This paper presents a distributed file organization for record-structured, disk-resident files with key-based exact-match access. The file is organized into buckets that are spread across multiple servers, where a server may hold multiple buckets. Client requests are serviced by mapping keys onto buckets and looking up the corresponding server in an address table. Dynamic growth in terms of file size and access load is supported by bucket splits and migration onto other existing or newly acquired servers.The significant and challenging problem addressed here is how to achieve scalability so that both the file size and the client throughput can be scaled up by linearly increasing the number of servers and dynamically redistributing data. Unlike previous work with similar objectives, our data redistribution considers explicitly the cost/performance ratio of the system by aiming to minimize the number of servers that are acquired to provide the required performance. A new server is acquired only if the overall server utilization in the system does not drop below a specified threshold. Preliminary simulation results show that the goal of scalability with controlled cost/performance is indeed achieved to a large extent.},
journal = {SIGMOD Rec.},
month = may,
pages = {253–264},
numpages = {12}
}

@inproceedings{10.1145/191839.191891,
author = {Kr\"{o}ll, Brigitte and Widmayer, Peter},
title = {Distributing a Search Tree among a Growing Number of Processors},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191891},
doi = {10.1145/191839.191891},
abstract = {Databases are growing steadily, and distributed computer systems are more and more easily available. This provides an opportunity to satisfy the increasingly tighter efficiency requirements by means of distributed data structures. The design and analysis of these structures under efficiency aspects, however, has not yet been studied sufficiently. To our knowledge, a single scalable, distributed data structure has been proposed so far. It is a distributed variant of linear hashing with uncontrolled splits, and, as a consequence, performs efficiently for data distributions that are close to uniform, but not necessarily for others. In addition, it does not support queries that refer to the linear order of keys, such as nearest neighbor or range queries. We propose a distributed search tree that avoids these problems, since it inherits desirable properties from non-distributed trees. Our experiments show that our structure does indeed combine a guarantee for good storage space utilization with high query efficiency. Nevertheless, we feel that further research in the area of scalable, distributed data structures is dearly needed; it should eventually lead to a body of knowledge that is comparable with the non-distributed, classical data structures field.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {265–276},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191891,
author = {Kr\"{o}ll, Brigitte and Widmayer, Peter},
title = {Distributing a Search Tree among a Growing Number of Processors},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191891},
doi = {10.1145/191843.191891},
abstract = {Databases are growing steadily, and distributed computer systems are more and more easily available. This provides an opportunity to satisfy the increasingly tighter efficiency requirements by means of distributed data structures. The design and analysis of these structures under efficiency aspects, however, has not yet been studied sufficiently. To our knowledge, a single scalable, distributed data structure has been proposed so far. It is a distributed variant of linear hashing with uncontrolled splits, and, as a consequence, performs efficiently for data distributions that are close to uniform, but not necessarily for others. In addition, it does not support queries that refer to the linear order of keys, such as nearest neighbor or range queries. We propose a distributed search tree that avoids these problems, since it inherits desirable properties from non-distributed trees. Our experiments show that our structure does indeed combine a guarantee for good storage space utilization with high query efficiency. Nevertheless, we feel that further research in the area of scalable, distributed data structures is dearly needed; it should eventually lead to a body of knowledge that is comparable with the non-distributed, classical data structures field.},
journal = {SIGMOD Rec.},
month = may,
pages = {265–276},
numpages = {12}
}

@inproceedings{10.1145/191839.191893,
author = {Dewan, Hasanat M. and Stolfo, Salvatore J. and Hern\'{a}ndez, Mauricio and Hwang, Jae-Jun},
title = {Predictive Dynamic Load Balancing of Parallel and Distributed Rule and Query Processing},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191893},
doi = {10.1145/191839.191893},
abstract = {Expert Databases are environments that support the processing of rule programs against a disk resident database. They occupy a position intermediate between active and deductive databases, with respect to the level of abstraction of the underlying rule language. The operational semantics of the rule language influences the problem solving strategy, while the architecture of the processing environment determines efficiency and scalability.In this paper, we present elements of the PARADISER architecture and its kernel rule language, PARULEL. The PARADISER environment provides support for parallel and distributed evaluation of rule programs, as well as static and dynamic load balancing protocols that predictively balance a computation at runtime. This combination of features results in a scalable database rule and complex query processing architecture. We validate our claims by analyzing the performance of the system for two realistic test cases. In particular, we show how the performance of a parallel implementation of transitive closure is significantly improved by predictive dynamic load balancing.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {277–288},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191893,
author = {Dewan, Hasanat M. and Stolfo, Salvatore J. and Hern\'{a}ndez, Mauricio and Hwang, Jae-Jun},
title = {Predictive Dynamic Load Balancing of Parallel and Distributed Rule and Query Processing},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191893},
doi = {10.1145/191843.191893},
abstract = {Expert Databases are environments that support the processing of rule programs against a disk resident database. They occupy a position intermediate between active and deductive databases, with respect to the level of abstraction of the underlying rule language. The operational semantics of the rule language influences the problem solving strategy, while the architecture of the processing environment determines efficiency and scalability.In this paper, we present elements of the PARADISER architecture and its kernel rule language, PARULEL. The PARADISER environment provides support for parallel and distributed evaluation of rule programs, as well as static and dynamic load balancing protocols that predictively balance a computation at runtime. This combination of features results in a scalable database rule and complex query processing architecture. We validate our claims by analyzing the performance of the system for two realistic test cases. In particular, we show how the performance of a parallel implementation of transitive closure is significantly improved by predictive dynamic load balancing.},
journal = {SIGMOD Rec.},
month = may,
pages = {277–288},
numpages = {12}
}

@inproceedings{10.1145/191839.191896,
author = {Tomasic, Anthony and Garc\'{\i}a-Molina, H\'{e}ctor and Shoens, Kurt},
title = {Incremental Updates of Inverted Lists for Text Document Retrieval},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191896},
doi = {10.1145/191839.191896},
abstract = {With the proliferation of the world's “information highways” a renewed interest in efficient document indexing techniques has come about. In this paper, the problem of incremental updates of inverted lists is addressed using a new dual-structure index. The index dynamically separates long and short inverted lists and optimizes retrieval, update, and storage of each type of list. To study the behavior of the index, a space of engineering trade-offs which range from optimizing update time to optimizing query performance is described. We quantitatively explore this space by using actual data and hardware in combination with a simulation of an information retrieval system. We then describe the best algorithm for a variety of criteria.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {289–300},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191896,
author = {Tomasic, Anthony and Garc\'{\i}a-Molina, H\'{e}ctor and Shoens, Kurt},
title = {Incremental Updates of Inverted Lists for Text Document Retrieval},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191896},
doi = {10.1145/191843.191896},
abstract = {With the proliferation of the world's “information highways” a renewed interest in efficient document indexing techniques has come about. In this paper, the problem of incremental updates of inverted lists is addressed using a new dual-structure index. The index dynamically separates long and short inverted lists and optimizes retrieval, update, and storage of each type of list. To study the behavior of the index, a space of engineering trade-offs which range from optimizing update time to optimizing query performance is described. We quantitatively explore this space by using actual data and hardware in combination with a simulation of an information retrieval system. We then describe the best algorithm for a variety of criteria.},
journal = {SIGMOD Rec.},
month = may,
pages = {289–300},
numpages = {12}
}

@inproceedings{10.1145/191839.191898,
author = {Consens, Mariano P. and Milo, Tova},
title = {Optimizing Queries on Files},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191898},
doi = {10.1145/191839.191898},
abstract = {We present a framework which allows the user to access and manipulate data uniformly, regardless of whether it resides in a database or in the file system (or in both). A key issue is the performance of the system. We show that text indexing, combined with newly developed optimization techniques, can be used to provide an efficient high level interface to information stored in files. Furthermore, using these techniques, some queries can be evaluated significantly faster than in standard database implementations. We also study the tradeoff between efficiency and the amount of indexing.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {301–312},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191898,
author = {Consens, Mariano P. and Milo, Tova},
title = {Optimizing Queries on Files},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191898},
doi = {10.1145/191843.191898},
abstract = {We present a framework which allows the user to access and manipulate data uniformly, regardless of whether it resides in a database or in the file system (or in both). A key issue is the performance of the system. We show that text indexing, combined with newly developed optimization techniques, can be used to provide an efficient high level interface to information stored in files. Furthermore, using these techniques, some queries can be evaluated significantly faster than in standard database implementations. We also study the tradeoff between efficiency and the amount of indexing.},
journal = {SIGMOD Rec.},
month = may,
pages = {301–312},
numpages = {12}
}

@inproceedings{10.1145/191839.191901,
author = {Christophides, V. and Abiteboul, S. and Cluet, S. and Scholl, M.},
title = {From Structured Documents to Novel Query Facilities},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191901},
doi = {10.1145/191839.191901},
abstract = {Structured documents (e.g., SGML) can benefit a lot from database support and more specifically from object-oriented database (OODB) management systems. This paper describes a natural mapping from SGML documents into OODB's and a formal extension of two OODB query languages (one SQL-like and the other calculus) in order to deal with SGML document retrieval.Although motivated by structured documents, the extensions of query languages that we present are general and useful for a variety of other OODB applications. A key element is the introduction of paths as first class citizens. The new features allow to query data (and to some extent schema) without exact knowledge of the schema in a simple and homogeneous fashion.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {313–324},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191901,
author = {Christophides, V. and Abiteboul, S. and Cluet, S. and Scholl, M.},
title = {From Structured Documents to Novel Query Facilities},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191901},
doi = {10.1145/191843.191901},
abstract = {Structured documents (e.g., SGML) can benefit a lot from database support and more specifically from object-oriented database (OODB) management systems. This paper describes a natural mapping from SGML documents into OODB's and a formal extension of two OODB query languages (one SQL-like and the other calculus) in order to deal with SGML document retrieval.Although motivated by structured documents, the extensions of query languages that we present are general and useful for a variety of other OODB applications. A key element is the introduction of paths as first class citizens. The new features allow to query data (and to some extent schema) without exact knowledge of the schema in a simple and homogeneous fashion.},
journal = {SIGMOD Rec.},
month = may,
pages = {313–324},
numpages = {12}
}

@inproceedings{10.1145/191839.191904,
author = {Hellerstein, Joseph M.},
title = {Practical Predicate Placement},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191904},
doi = {10.1145/191839.191904},
abstract = {Recent work in query optimization has addressed the issue of placing expensive predicates in a query plan. In this paper we explore the predicate placement options considered in the Montage DBMS, presenting a family of algorithms that form successively more complex and effective optimization solutions. Through analysis and performance measurements of Montage SQL queries, we classify queries and highlight the simplest solution that will optimize each class correctly. We demonstrate limitations of previously published algorithms, and discuss the challenges and feasibility of implementing the various algorithms in a commercial-grade system.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {325–335},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191904,
author = {Hellerstein, Joseph M.},
title = {Practical Predicate Placement},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191904},
doi = {10.1145/191843.191904},
abstract = {Recent work in query optimization has addressed the issue of placing expensive predicates in a query plan. In this paper we explore the predicate placement options considered in the Montage DBMS, presenting a family of algorithms that form successively more complex and effective optimization solutions. Through analysis and performance measurements of Montage SQL queries, we classify queries and highlight the simplest solution that will optimize each class correctly. We demonstrate limitations of previously published algorithms, and discuss the challenges and feasibility of implementing the various algorithms in a commercial-grade system.},
journal = {SIGMOD Rec.},
month = may,
pages = {325–335},
numpages = {11}
}

@inproceedings{10.1145/191839.191906,
author = {Kemper, A. and Moerkotte, G. and Peithner, K. and Steinbrunn, M.},
title = {Optimizing Disjunctive Queries with Expensive Predicates},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191906},
doi = {10.1145/191839.191906},
abstract = {In this work, we propose and assess a technique called bypass processing for optimizing the evaluation of disjunctive queries with expensive predicates. The technique is particularly useful for optimizing selection predicates that contain terms whose evaluation costs vary tremendously; e.g., the evaluation of a nested subquery or the invocation of a user-defined function in an object-oriented or extended relational model may be orders of magnitude more expensive than an attribute access (and comparison). The idea of bypass processing consists of avoiding the evaluation of such expensive terms whenever the outcome of the entire selection predicate can already be induced by testing other, less expensive terms. In order to validate the viability of bypass evaluation, we extend a previously developed optimizer architecture and incorporate three alternative optimization algorithms for generating bypass processing plans.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {336–347},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191906,
author = {Kemper, A. and Moerkotte, G. and Peithner, K. and Steinbrunn, M.},
title = {Optimizing Disjunctive Queries with Expensive Predicates},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191906},
doi = {10.1145/191843.191906},
abstract = {In this work, we propose and assess a technique called bypass processing for optimizing the evaluation of disjunctive queries with expensive predicates. The technique is particularly useful for optimizing selection predicates that contain terms whose evaluation costs vary tremendously; e.g., the evaluation of a nested subquery or the invocation of a user-defined function in an object-oriented or extended relational model may be orders of magnitude more expensive than an attribute access (and comparison). The idea of bypass processing consists of avoiding the evaluation of such expensive terms whenever the outcome of the entire selection predicate can already be induced by testing other, less expensive terms. In order to validate the viability of bypass evaluation, we extend a previously developed optimizer architecture and incorporate three alternative optimization algorithms for generating bypass processing plans.},
journal = {SIGMOD Rec.},
month = may,
pages = {336–347},
numpages = {12}
}

@inproceedings{10.1145/191839.191908,
author = {Galindo-Legaria, C\'{e}sar A.},
title = {Outerjoins as Disjunctions},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191908},
doi = {10.1145/191839.191908},
abstract = {The outerjoin operator is currently available in the query language of several major DBMSs, and it is included in the proposed SQL2 standard draft. However, “associativity problems” of the operator have been pointed out since its introduction. In this paper we propose a shift in the intuition behind outerjoin: Instead of computing the join while also preserving its arguments, outerjoin delivers tuples that come either from the join or from the arguments. Queries with joins and outerjoins deliver tuples that come from one out of several joins, where a single relation is a trivial join. An advantage of this view is that, in contrast to preservation, disjunction is commutative and associative, which is a significant property for intuition, formalisms, and generation of execution plans.Based on a disjunctive normal form, we show that some data merging queries cannot be evaluated by means of binary outerjoins, and give alternative procedures to evaluate those queries. We also explore several evaluation strategies for outerjoin queries, including the use of semijoin programs to reduce base relations.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {348–358},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191908,
author = {Galindo-Legaria, C\'{e}sar A.},
title = {Outerjoins as Disjunctions},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191908},
doi = {10.1145/191843.191908},
abstract = {The outerjoin operator is currently available in the query language of several major DBMSs, and it is included in the proposed SQL2 standard draft. However, “associativity problems” of the operator have been pointed out since its introduction. In this paper we propose a shift in the intuition behind outerjoin: Instead of computing the join while also preserving its arguments, outerjoin delivers tuples that come either from the join or from the arguments. Queries with joins and outerjoins deliver tuples that come from one out of several joins, where a single relation is a trivial join. An advantage of this view is that, in contrast to preservation, disjunction is commutative and associative, which is a significant property for intuition, formalisms, and generation of execution plans.Based on a disjunctive normal form, we show that some data merging queries cannot be evaluated by means of binary outerjoins, and give alternative procedures to evaluate those queries. We also explore several evaluation strategies for outerjoin queries, including the use of semijoin programs to reduce base relations.},
journal = {SIGMOD Rec.},
month = may,
pages = {348–358},
numpages = {11}
}

@inproceedings{10.1145/191839.191911,
author = {Carey, Michael J. and Franklin, Michael J. and Zaharioudakis, Markos},
title = {Fine-Grained Sharing in a Page Server OODBMS},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191911},
doi = {10.1145/191839.191911},
abstract = {For reasons of simplicity and communication efficiency, a number of existing object-oriented database management systems are based on page server architectures; data pages are their minimum unit of transfer and client caching. Despite their efficiency, page servers are often criticized as being too restrictive when it comes to concurrency, as existing systems use pages as the minimum locking unit as well. In this paper we show how to support object-level locking in a page server context. Several approaches are described, including an adaptive granularity approach that uses page-level locking for most pages but switches to object-level locking when finer-grained sharing is demanded. We study the performance of these approaches, comparing them to both a pure page server and a pure  object server. For the range of workloads that we have examined, our results indicate that a page server is clearly preferable to an object server. Moreover, the adaptive page server is shown to provide very good performance, generally outperforming the pure page server, the pure object server, and the other alternatives as well.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {359–370},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191911,
author = {Carey, Michael J. and Franklin, Michael J. and Zaharioudakis, Markos},
title = {Fine-Grained Sharing in a Page Server OODBMS},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191911},
doi = {10.1145/191843.191911},
abstract = {For reasons of simplicity and communication efficiency, a number of existing object-oriented database management systems are based on page server architectures; data pages are their minimum unit of transfer and client caching. Despite their efficiency, page servers are often criticized as being too restrictive when it comes to concurrency, as existing systems use pages as the minimum locking unit as well. In this paper we show how to support object-level locking in a page server context. Several approaches are described, including an adaptive granularity approach that uses page-level locking for most pages but switches to object-level locking when finer-grained sharing is demanded. We study the performance of these approaches, comparing them to both a pure page server and a pure  object server. For the range of workloads that we have examined, our results indicate that a page server is clearly preferable to an object server. Moreover, the adaptive page server is shown to provide very good performance, generally outperforming the pure page server, the pure object server, and the other alternatives as well.},
journal = {SIGMOD Rec.},
month = may,
pages = {359–370},
numpages = {12}
}

@inproceedings{10.1145/191839.191913,
author = {Cook, Jonathan E. and Wolf, Alexander L. and Zorn, Benjamin G.},
title = {Partition Selection Policies in Object Database Garbage Collection},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191913},
doi = {10.1145/191839.191913},
abstract = {The automatic reclamation of storage for unreferenced objects is very important in object databases. Existing language system algorithms for automatic storage reclamation have been shown to be inappropriate. In this paper, we investigate methods to improve the performance of algorithms for automatic for automatic storage reclamation of object databases. These algorithms are based on a technique called partitioned garbage collection, in which a subset of the entire database is collected independently of the rest. Specifically, we investigate the policy that is used to select what partition in the database should be collected. The policies that we propose and investigate are based on the intuition that the values of overwritten pointers provide good hints about  where to find garbage. Using trace-driven simulation, we show that one of our policies requires less I/O to collect more garbage than any existing implementable policy and performs close to a near-optimal policy over a wide range of database sizes and object connectivities.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {371–382},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191913,
author = {Cook, Jonathan E. and Wolf, Alexander L. and Zorn, Benjamin G.},
title = {Partition Selection Policies in Object Database Garbage Collection},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191913},
doi = {10.1145/191843.191913},
abstract = {The automatic reclamation of storage for unreferenced objects is very important in object databases. Existing language system algorithms for automatic storage reclamation have been shown to be inappropriate. In this paper, we investigate methods to improve the performance of algorithms for automatic for automatic storage reclamation of object databases. These algorithms are based on a technique called partitioned garbage collection, in which a subset of the entire database is collected independently of the rest. Specifically, we investigate the policy that is used to select what partition in the database should be collected. The policies that we propose and investigate are based on the intuition that the values of overwritten pointers provide good hints about  where to find garbage. Using trace-driven simulation, we show that one of our policies requires less I/O to collect more garbage than any existing implementable policy and performs close to a near-optimal policy over a wide range of database sizes and object connectivities.},
journal = {SIGMOD Rec.},
month = may,
pages = {371–382},
numpages = {12}
}

@inproceedings{10.1145/191839.191915,
author = {Carey, Michael J. and DeWitt, David J. and Franklin, Michael J. and Hall, Nancy E. and McAuliffe, Mark L. and Naughton, Jeffrey F. and Schuh, Daniel T. and Solomon, Marvin H. and Tan, C. K. and Tsatalos, Odysseas G. and White, Seth J. and Zwilling, Michael J.},
title = {Shoring up Persistent Applications},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191915},
doi = {10.1145/191839.191915},
abstract = {SHORE (Scalable Heterogeneous Object REpository) is a persistent object system under development at the University of Wisconsin. SHORE represents a merger of object-oriented database and file system technologies. In this paper we give the goals and motivation for SHORE, and describe how SHORE provides features of both technologies. We also describe some novel aspects of the SHORE architecture, including a symmetric peer-to-peer server architecture, server customization through an extensible value-added server facility, and support for scalability on multiprocessor systems. An initial version of SHORE is already operational, and we expect a release of Version 1 in mid-1994.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {383–394},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191915,
author = {Carey, Michael J. and DeWitt, David J. and Franklin, Michael J. and Hall, Nancy E. and McAuliffe, Mark L. and Naughton, Jeffrey F. and Schuh, Daniel T. and Solomon, Marvin H. and Tan, C. K. and Tsatalos, Odysseas G. and White, Seth J. and Zwilling, Michael J.},
title = {Shoring up Persistent Applications},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191915},
doi = {10.1145/191843.191915},
abstract = {SHORE (Scalable Heterogeneous Object REpository) is a persistent object system under development at the University of Wisconsin. SHORE represents a merger of object-oriented database and file system technologies. In this paper we give the goals and motivation for SHORE, and describe how SHORE provides features of both technologies. We also describe some novel aspects of the SHORE architecture, including a symmetric peer-to-peer server architecture, server customization through an extensible value-added server facility, and support for scalability on multiprocessor systems. An initial version of SHORE is already operational, and we expect a release of Version 1 in mid-1994.},
journal = {SIGMOD Rec.},
month = may,
pages = {383–394},
numpages = {12}
}

@inproceedings{10.1145/191839.191919,
author = {White, Seth J. and DeWitt, David J.},
title = {QuickStore: A High Performance Mapped Object Store},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191919},
doi = {10.1145/191839.191919},
abstract = {This paper presents, QuickStore, a memory-mapped storage system for persistent C++ built on top of the EXODUS Storage Manager. QuickStore provides fast access to in-memory objects by allowing application programs to access objects via normal virtual memory pointers. The paper also presents the results of a detailed performance study using the OO7 benchmark. The study compares the performance of QuickStore with the latest implementation of the E programming language. These systems exemplify the two basic approaches (hardware and software) that have been used to implement persistence in object-oriented database systems. Both systems use the same underlying storage manager and compiler allowing us to make a truly apples-to-apples comparison of the hardware and software techniques.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {395–406},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191919,
author = {White, Seth J. and DeWitt, David J.},
title = {QuickStore: A High Performance Mapped Object Store},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191919},
doi = {10.1145/191843.191919},
abstract = {This paper presents, QuickStore, a memory-mapped storage system for persistent C++ built on top of the EXODUS Storage Manager. QuickStore provides fast access to in-memory objects by allowing application programs to access objects via normal virtual memory pointers. The paper also presents the results of a detailed performance study using the OO7 benchmark. The study compares the performance of QuickStore with the latest implementation of the E programming language. These systems exemplify the two basic approaches (hardware and software) that have been used to implement persistence in object-oriented database systems. Both systems use the same underlying storage manager and compiler allowing us to make a truly apples-to-apples comparison of the hardware and software techniques.},
journal = {SIGMOD Rec.},
month = may,
pages = {395–406},
numpages = {12}
}

@inproceedings{10.1145/191839.191924,
author = {McIver, William J. and King, Roger},
title = {Self-Adaptive, on-Line Reclustering of Complex Object Data},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191924},
doi = {10.1145/191839.191924},
abstract = {A likely trend in the development of future CAD, CASE and office information systems will be the use of object-oriented database systems to manage their internal data stores. The entities that these applications will retrieve, such as electronic parts and their connections or customer service records, are typically large complex objects composed of many interconnected heterogeneous objects, not thousands of tuples. These applications may exhibit widely shifting usage patterns due to their interactive mode of operation. Such a class of applications would demand clustering methods that are appropriate for clustering large complex objects and that can adapt on-line to the shifting usage patterns. While most object-oriented clustering methods allow grouping of heterogeneous objects, they  are usually static and can only be changed off-line. We present one possible architecture for performing complex object reclustering in an on-line manner that is adaptive to changing usage patterns. Our architecture involves the decomposition of a clustering method into concurrently operating components that each handle one of the fundamental tasks involved in reclustering, namely statistics collection, cluster analysis, and reorganization. We present the results of an experiment performed to evaluate its behavior. These results show that the average miss rate for object accesses can be effectively reduced using a combination of rules that we have developed for deciding when cluster analyses and reorganizations should be performed.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {407–418},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191924,
author = {McIver, William J. and King, Roger},
title = {Self-Adaptive, on-Line Reclustering of Complex Object Data},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191924},
doi = {10.1145/191843.191924},
abstract = {A likely trend in the development of future CAD, CASE and office information systems will be the use of object-oriented database systems to manage their internal data stores. The entities that these applications will retrieve, such as electronic parts and their connections or customer service records, are typically large complex objects composed of many interconnected heterogeneous objects, not thousands of tuples. These applications may exhibit widely shifting usage patterns due to their interactive mode of operation. Such a class of applications would demand clustering methods that are appropriate for clustering large complex objects and that can adapt on-line to the shifting usage patterns. While most object-oriented clustering methods allow grouping of heterogeneous objects, they  are usually static and can only be changed off-line. We present one possible architecture for performing complex object reclustering in an on-line manner that is adaptive to changing usage patterns. Our architecture involves the decomposition of a clustering method into concurrently operating components that each handle one of the fundamental tasks involved in reclustering, namely statistics collection, cluster analysis, and reorganization. We present the results of an experiment performed to evaluate its behavior. These results show that the average miss rate for object accesses can be effectively reduced using a combination of rules that we have developed for deciding when cluster analyses and reorganizations should be performed.},
journal = {SIGMOD Rec.},
month = may,
pages = {407–418},
numpages = {12}
}

@inproceedings{10.1145/191839.191925,
author = {Faloutsos, Christos and Ranganathan, M. and Manolopoulos, Yannis},
title = {Fast Subsequence Matching in Time-Series Databases},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191925},
doi = {10.1145/191839.191925},
abstract = {We present an efficient indexing method to locate 1-dimensional subsequences within a collection of sequences, such that the subsequences match a given (query) pattern within a specified tolerance. The idea is to map each data sequences into a small set of multidimensional rectangles in feature space. Then, these rectangles can be readily indexed using traditional spatial access methods, like the R*-tree [9]. In more detail, we use a sliding window over the data sequence and extract its features; the result is a trail in feature space. We propose an efficient and effective algorithm to divide such trails into sub-trails, which  are subsequently represented by their Minimum Bounding Rectangles (MBRs). We also examine queries of varying lengths, and we show how to handle each case efficiently. We implemented our method and carried out experiments on synthetic and real data (stock price movements). We compared the method to sequential scanning, which is the only obvious competitor. The results were excellent: our method accelerated the search time from 3 times up to 100 times.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {419–429},
numpages = {11},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191925,
author = {Faloutsos, Christos and Ranganathan, M. and Manolopoulos, Yannis},
title = {Fast Subsequence Matching in Time-Series Databases},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191925},
doi = {10.1145/191843.191925},
abstract = {We present an efficient indexing method to locate 1-dimensional subsequences within a collection of sequences, such that the subsequences match a given (query) pattern within a specified tolerance. The idea is to map each data sequences into a small set of multidimensional rectangles in feature space. Then, these rectangles can be readily indexed using traditional spatial access methods, like the R*-tree [9]. In more detail, we use a sliding window over the data sequence and extract its features; the result is a trail in feature space. We propose an efficient and effective algorithm to divide such trails into sub-trails, which  are subsequently represented by their Minimum Bounding Rectangles (MBRs). We also examine queries of varying lengths, and we show how to handle each case efficiently. We implemented our method and carried out experiments on synthetic and real data (stock price movements). We compared the method to sequential scanning, which is the only obvious competitor. The results were excellent: our method accelerated the search time from 3 times up to 100 times.},
journal = {SIGMOD Rec.},
month = may,
pages = {419–429},
numpages = {11}
}

@inproceedings{10.1145/191839.191926,
author = {Seshadri, Praveen and Livny, Miron and Ramakrishnan, Raghu},
title = {Sequence Query Processing},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191926},
doi = {10.1145/191839.191926},
abstract = {Many applications require the ability to manipulate sequences of data. We motivate the importance of sequence query processing, and present a framework for the optimization of sequence queries based on several novel techniques. These include query transformations, optimizations that utilize meta-data, and caching of intermediate results. We present a bottom-up algorithm that generates an efficient query evaluation plan based on cost estimates. This work also identifies a number of directions in which future research can be directed.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {430–441},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191926,
author = {Seshadri, Praveen and Livny, Miron and Ramakrishnan, Raghu},
title = {Sequence Query Processing},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191926},
doi = {10.1145/191843.191926},
abstract = {Many applications require the ability to manipulate sequences of data. We motivate the importance of sequence query processing, and present a framework for the optimization of sequence queries based on several novel techniques. These include query transformations, optimizations that utilize meta-data, and caching of intermediate results. We present a bottom-up algorithm that generates an efficient query evaluation plan based on cost estimates. This work also identifies a number of directions in which future research can be directed.},
journal = {SIGMOD Rec.},
month = may,
pages = {430–441},
numpages = {12}
}

@inproceedings{10.1145/191839.191927,
author = {Sagonas, Konstantinos and Swift, Terrance and Warren, David S.},
title = {XSB as an Efficient Deductive Database Engine},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191927},
doi = {10.1145/191839.191927},
abstract = {This paper describes the XSB system, and its use as an in-memory deductive database engine. XSB began from a Prolog foundation, and traditional Prolog systems are known to have serious deficiencies when used as database systems. Accordingly, XSB has a fundamental bottom-up extension, introduced through tabling (or memoing)[4], which makes it appropriate as an underlying query engine for deductive database systems. Because it eliminates redundant computation, the tabling extension makes XSB able to compute all modularly stratified datalog programs finitely and with polynomial data complexity. For non-stratified programs, a meta-interpreter with the same properties is provided. In addition XSB significantly extends and improves the indexing capabilities over those of standard Prolog.  Finally, its syntactic basis in HiLog [2], lends it flexibility for data modelling.The implementation of XSB derives from the WAM [25], the most common Prolog engine. XSB inherits the WAM's efficiency and can take advantage of extensive compiler technology developed for Prolog. As a result, performance comparisons indicate that XSB is significantly faster than other deductive database systems for a wide range of queries and stratified rule sets. XSB is under continuous development, and version 1.3 is available through anonymous ftp.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {442–453},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191927,
author = {Sagonas, Konstantinos and Swift, Terrance and Warren, David S.},
title = {XSB as an Efficient Deductive Database Engine},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191927},
doi = {10.1145/191843.191927},
abstract = {This paper describes the XSB system, and its use as an in-memory deductive database engine. XSB began from a Prolog foundation, and traditional Prolog systems are known to have serious deficiencies when used as database systems. Accordingly, XSB has a fundamental bottom-up extension, introduced through tabling (or memoing)[4], which makes it appropriate as an underlying query engine for deductive database systems. Because it eliminates redundant computation, the tabling extension makes XSB able to compute all modularly stratified datalog programs finitely and with polynomial data complexity. For non-stratified programs, a meta-interpreter with the same properties is provided. In addition XSB significantly extends and improves the indexing capabilities over those of standard Prolog.  Finally, its syntactic basis in HiLog [2], lends it flexibility for data modelling.The implementation of XSB derives from the WAM [25], the most common Prolog engine. XSB inherits the WAM's efficiency and can take advantage of extensive compiler technology developed for Prolog. As a result, performance comparisons indicate that XSB is significantly faster than other deductive database systems for a wide range of queries and stratified rule sets. XSB is under continuous development, and version 1.3 is available through anonymous ftp.},
journal = {SIGMOD Rec.},
month = may,
pages = {442–453},
numpages = {12}
}

@inproceedings{10.1145/191839.191928,
author = {Dar, Shaul and Ramakrishnan, Raghu},
title = {A Performance Study of Transitive Closure Algorithms},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191928},
doi = {10.1145/191839.191928},
abstract = {We present a comprehensive performance evaluation of transitive closure (reachability) algorithms for databases. The study is based upon careful implementations of the algorithms, measures page I/O, and covers algorithms for full transitive closure as well as partial transitive closure (finding all successors of each node in a set of given source nodes). We examine a wide range of acyclic graphs with varying density and “locality” of arcs in the graph. We also consider query parameters such as the selectivity of the query, and system parameters such as the buffer size and the page and successor list replacement policies. We show that significant cost tradeoffs exist between the algorithms in this spectrum and identify the factors that influence the performance of the algorithms.An important aspect of our work is that we measure a number of different cost metrics, giving us a good understanding of the predictive power of these metrics with respect to I/O cost. This is especially significant since metrics such as number of tuples generated or number of successor list operations have been widely used to compare transitive closure algorithms in the literature. Our results strongly suggest that these other metrics cannot be reliability used to predict I/O cost of transitive closure evaluation.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {454–465},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191928,
author = {Dar, Shaul and Ramakrishnan, Raghu},
title = {A Performance Study of Transitive Closure Algorithms},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191928},
doi = {10.1145/191843.191928},
abstract = {We present a comprehensive performance evaluation of transitive closure (reachability) algorithms for databases. The study is based upon careful implementations of the algorithms, measures page I/O, and covers algorithms for full transitive closure as well as partial transitive closure (finding all successors of each node in a set of given source nodes). We examine a wide range of acyclic graphs with varying density and “locality” of arcs in the graph. We also consider query parameters such as the selectivity of the query, and system parameters such as the buffer size and the page and successor list replacement policies. We show that significant cost tradeoffs exist between the algorithms in this spectrum and identify the factors that influence the performance of the algorithms.An important aspect of our work is that we measure a number of different cost metrics, giving us a good understanding of the predictive power of these metrics with respect to I/O cost. This is especially significant since metrics such as number of tuples generated or number of successor list operations have been widely used to compare transitive closure algorithms in the literature. Our results strongly suggest that these other metrics cannot be reliability used to predict I/O cost of transitive closure evaluation.},
journal = {SIGMOD Rec.},
month = may,
pages = {454–465},
numpages = {12}
}

@inproceedings{10.1145/191839.191929,
author = {Carey, Michael J.},
title = {Parallel Database Systems in the 1990's},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191929},
doi = {10.1145/191839.191929},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {466},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191929,
author = {Carey, Michael J.},
title = {Parallel Database Systems in the 1990's},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191929},
doi = {10.1145/191843.191929},
journal = {SIGMOD Rec.},
month = may,
pages = {466},
numpages = {1}
}

@inproceedings{10.1145/191839.191930,
author = {Daniels, Dean and Doo, Lip Boon and Downing, Alan and Elsbernd, Curtis and Hallmark, Gary and Jain, Sandeep and Jenkins, Bob and Lim, Peter and Smith, Gordon and Souder, Benny and Stamos, Jim},
title = {Oracle's Symmetric Replication Technology and Implications for Application Design},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191930},
doi = {10.1145/191839.191930},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {467},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191930,
author = {Daniels, Dean and Doo, Lip Boon and Downing, Alan and Elsbernd, Curtis and Hallmark, Gary and Jain, Sandeep and Jenkins, Bob and Lim, Peter and Smith, Gordon and Souder, Benny and Stamos, Jim},
title = {Oracle's Symmetric Replication Technology and Implications for Application Design},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191930},
doi = {10.1145/191843.191930},
journal = {SIGMOD Rec.},
month = may,
pages = {467},
numpages = {1}
}

@inproceedings{10.1145/191839.191931,
author = {Dietterich, Daniel J.},
title = {DEC Data Distributor: For Data Replication and Data Warehousing},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191931},
doi = {10.1145/191839.191931},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {468},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191931,
author = {Dietterich, Daniel J.},
title = {DEC Data Distributor: For Data Replication and Data Warehousing},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191931},
doi = {10.1145/191843.191931},
journal = {SIGMOD Rec.},
month = may,
pages = {468},
numpages = {1}
}

@inproceedings{10.1145/191839.191932,
author = {Gorelik, Alex and Wang, Yongdong and Deppe, Mark},
title = {Sybase Replication Server},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191932},
doi = {10.1145/191839.191932},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {469},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191932,
author = {Gorelik, Alex and Wang, Yongdong and Deppe, Mark},
title = {Sybase Replication Server},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191932},
doi = {10.1145/191843.191932},
journal = {SIGMOD Rec.},
month = may,
pages = {469},
numpages = {1}
}

@inproceedings{10.1145/191839.191933,
author = {Laursen, Andrew and Olkin, Jeffrey and Porter, Mark},
title = {Oracle Media Server: Providing Consumer Based Interactive Access to Multimedia Data},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191933},
doi = {10.1145/191839.191933},
abstract = {Currently, most data accessed on large servers is structured data stored in traditional databases. Networks are LAN based and clients range from simple terminals to powerful workstations. The user is corporate  and the application developer is an MIS professional.With the introduction of broadband communications to the home and better than 100-to-1 compression techniques, a new form of network-based computing is emerging. Structured data is still important, but the bulk of data becomes unstructured: audio, video, news feeds, etc. The predominant user becomes the consumer. The predominant client device becomes the television set. The application developer becomes the storyboard developer, director, or the video production engineer.The Oracle Media Server supports  access to all types of conventional data stored in Oracle relational and text databases. In addition, we have developed a real-time stream server that supports storage and playback of real-time audio and video data. The Media Server also provides access to data stored in file systems or as binary large objects (images, executables, etc.)The Oracle Media Server provides a platform for distributed client-server computing and access to data over asymmetric real-time networks. A service mechanism allows applications to be split such that client devices (set-top boxes, personal digital assistants, etc.) can focus on presentation, while backend services running in a distributed server complex, provide access to data via messaging or lightweight RPC (Remote Procedure Call).},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {470–477},
numpages = {8},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191933,
author = {Laursen, Andrew and Olkin, Jeffrey and Porter, Mark},
title = {Oracle Media Server: Providing Consumer Based Interactive Access to Multimedia Data},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191933},
doi = {10.1145/191843.191933},
abstract = {Currently, most data accessed on large servers is structured data stored in traditional databases. Networks are LAN based and clients range from simple terminals to powerful workstations. The user is corporate  and the application developer is an MIS professional.With the introduction of broadband communications to the home and better than 100-to-1 compression techniques, a new form of network-based computing is emerging. Structured data is still important, but the bulk of data becomes unstructured: audio, video, news feeds, etc. The predominant user becomes the consumer. The predominant client device becomes the television set. The application developer becomes the storyboard developer, director, or the video production engineer.The Oracle Media Server supports  access to all types of conventional data stored in Oracle relational and text databases. In addition, we have developed a real-time stream server that supports storage and playback of real-time audio and video data. The Media Server also provides access to data stored in file systems or as binary large objects (images, executables, etc.)The Oracle Media Server provides a platform for distributed client-server computing and access to data over asymmetric real-time networks. A service mechanism allows applications to be split such that client devices (set-top boxes, personal digital assistants, etc.) can focus on presentation, while backend services running in a distributed server complex, provide access to data via messaging or lightweight RPC (Remote Procedure Call).},
journal = {SIGMOD Rec.},
month = may,
pages = {470–477},
numpages = {8}
}

@inproceedings{10.1145/191839.191935,
author = {Kulkarni, Krishna G.},
title = {Object-Oriented Extensions in SQL3: A Status Report},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191935},
doi = {10.1145/191839.191935},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {478},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191935,
author = {Kulkarni, Krishna G.},
title = {Object-Oriented Extensions in SQL3: A Status Report},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191935},
doi = {10.1145/191843.191935},
journal = {SIGMOD Rec.},
month = may,
pages = {478},
numpages = {1}
}

@inproceedings{10.1145/191839.191936,
author = {Martin, Bruce E.},
title = {COSS: The Common Object Services Specifications},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191936},
doi = {10.1145/191839.191936},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {479},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191936,
author = {Martin, Bruce E.},
title = {COSS: The Common Object Services Specifications},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191936},
doi = {10.1145/191843.191936},
journal = {SIGMOD Rec.},
month = may,
pages = {479},
numpages = {1}
}

@inproceedings{10.1145/191839.191937,
author = {Cattell, R. G. G.},
title = {ODMG-93: A Standard for Object-Oriented DBMSs},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191937},
doi = {10.1145/191839.191937},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {480},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191937,
author = {Cattell, R. G. G.},
title = {ODMG-93: A Standard for Object-Oriented DBMSs},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191937},
doi = {10.1145/191843.191937},
journal = {SIGMOD Rec.},
month = may,
pages = {480},
numpages = {1}
}

@inproceedings{10.1145/191839.191938,
author = {Kim, Won},
title = {UniSQL/X Unified Relational and Object-Oriented Database System},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191938},
doi = {10.1145/191839.191938},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {481},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191938,
author = {Kim, Won},
title = {UniSQL/X Unified Relational and Object-Oriented Database System},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191938},
doi = {10.1145/191843.191938},
journal = {SIGMOD Rec.},
month = may,
pages = {481},
numpages = {1}
}

@inproceedings{10.1145/191839.191939,
author = {Ubell, Michael},
title = {The Montage Extensible DataBlade Architecture},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191939},
doi = {10.1145/191839.191939},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {482},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191939,
author = {Ubell, Michael},
title = {The Montage Extensible DataBlade Architecture},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191939},
doi = {10.1145/191843.191939},
journal = {SIGMOD Rec.},
month = may,
pages = {482},
numpages = {1}
}

@inproceedings{10.1145/191839.191941,
author = {Pirahesh, Hamid},
title = {Object-Oriented Features of DB2 Client/Server},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191941},
doi = {10.1145/191839.191941},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {483},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191941,
author = {Pirahesh, Hamid},
title = {Object-Oriented Features of DB2 Client/Server},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191941},
doi = {10.1145/191843.191941},
journal = {SIGMOD Rec.},
month = may,
pages = {483},
numpages = {1}
}

@inproceedings{10.1145/191839.191942,
author = {Vaskevitch, David},
title = {Database in Crisis and Transition: A Technical Agenda for the Year 2001},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191942},
doi = {10.1145/191839.191942},
abstract = {The current paper outlines a number of important changes that face the database community and presents an agenda for how some of these challenges can be met. This database agenda is currently being addressed in the Enterprise Group at Microsoft Corporation. The paper concludes with a scenario for 2001 which reflects the Microsoft vision of “Information at your fingertips.”},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {484–489},
numpages = {6},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191942,
author = {Vaskevitch, David},
title = {Database in Crisis and Transition: A Technical Agenda for the Year 2001},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191942},
doi = {10.1145/191843.191942},
abstract = {The current paper outlines a number of important changes that face the database community and presents an agenda for how some of these challenges can be met. This database agenda is currently being addressed in the Enterprise Group at Microsoft Corporation. The paper concludes with a scenario for 2001 which reflects the Microsoft vision of “Information at your fingertips.”},
journal = {SIGMOD Rec.},
month = may,
pages = {484–489},
numpages = {6}
}

@inproceedings{10.1145/191839.191944,
author = {Ballinger, Carrie},
title = {Evolving Teradata Decision Support for Massively Parallel Processing with UNIX},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191944},
doi = {10.1145/191839.191944},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {490},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191944,
author = {Ballinger, Carrie},
title = {Evolving Teradata Decision Support for Massively Parallel Processing with UNIX},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191944},
doi = {10.1145/191843.191944},
journal = {SIGMOD Rec.},
month = may,
pages = {490},
numpages = {1}
}

@inproceedings{10.1145/191839.191945,
author = {Englert, Susanne},
title = {Nonstop SQL: Scalability and Availability for Decision Support},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191945},
doi = {10.1145/191839.191945},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {491},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191945,
author = {Englert, Susanne},
title = {Nonstop SQL: Scalability and Availability for Decision Support},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191945},
doi = {10.1145/191843.191945},
journal = {SIGMOD Rec.},
month = may,
pages = {491},
numpages = {1}
}

@inproceedings{10.1145/191839.191947,
author = {Fernandez, Phillip M.},
title = {Red Brick Warehouse: A Read-Mostly RDBMS for Open SMP Platforms},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191947},
doi = {10.1145/191839.191947},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {492},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191947,
author = {Fernandez, Phillip M.},
title = {Red Brick Warehouse: A Read-Mostly RDBMS for Open SMP Platforms},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191947},
doi = {10.1145/191843.191947},
journal = {SIGMOD Rec.},
month = may,
pages = {492},
numpages = {1}
}

@inproceedings{10.1145/191839.191948,
author = {Melling, Wesley P.},
title = {Enterprise Information Architectures—They're Finally Changing},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191948},
doi = {10.1145/191839.191948},
abstract = {Substantive changes in the business environment—and aggressive initiatives in business process reengineering—are driving corresponding changes in the information technology architectures of large enterprises. Those changes are enabled by the convergence of a long list of maturing new technologies. As one of its many implications, the new IT architecture demands revised assumptions about the design and deployment of databases. This paper reviews the components of the architectural shift now in process, and offers strategic planning assumptions for database professionals.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {493–504},
numpages = {12},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191948,
author = {Melling, Wesley P.},
title = {Enterprise Information Architectures—They're Finally Changing},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191948},
doi = {10.1145/191843.191948},
abstract = {Substantive changes in the business environment—and aggressive initiatives in business process reengineering—are driving corresponding changes in the information technology architectures of large enterprises. Those changes are enabled by the convergence of a long list of maturing new technologies. As one of its many implications, the new IT architecture demands revised assumptions about the design and deployment of databases. This paper reviews the components of the architectural shift now in process, and offers strategic planning assumptions for database professionals.},
journal = {SIGMOD Rec.},
month = may,
pages = {493–504},
numpages = {12}
}

@inproceedings{10.1145/191839.191949,
author = {Singh, Munindar P. and Tomlinson, Christine and Woelk, Darrell},
title = {Relaxed Transaction Processing},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191949},
doi = {10.1145/191839.191949},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {505},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191949,
author = {Singh, Munindar P. and Tomlinson, Christine and Woelk, Darrell},
title = {Relaxed Transaction Processing},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191949},
doi = {10.1145/191843.191949},
journal = {SIGMOD Rec.},
month = may,
pages = {505},
numpages = {1}
}

@inproceedings{10.1145/191839.191951,
author = {Flokstra, Jan and van Keulen, Maurice and Skowronek, Jacek},
title = {The IMPRESS DDT: A Database Design Toolbox Based on a Formal Specification Language},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191951},
doi = {10.1145/191839.191951},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {506},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191951,
author = {Flokstra, Jan and van Keulen, Maurice and Skowronek, Jacek},
title = {The IMPRESS DDT: A Database Design Toolbox Based on a Formal Specification Language},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191951},
doi = {10.1145/191843.191951},
journal = {SIGMOD Rec.},
month = may,
pages = {506},
numpages = {1}
}

@inproceedings{10.1145/191839.191955,
author = {Bryan, G. M. and Moore, W. E. and Curry, B. J. and Lodge, K. W. and Geyer, J.},
title = {The MEDUSA Project: Autonomous Data Management in a Shared-Nothing Parallel Database Machine},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191955},
doi = {10.1145/191839.191955},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {507},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191955,
author = {Bryan, G. M. and Moore, W. E. and Curry, B. J. and Lodge, K. W. and Geyer, J.},
title = {The MEDUSA Project: Autonomous Data Management in a Shared-Nothing Parallel Database Machine},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191955},
doi = {10.1145/191843.191955},
journal = {SIGMOD Rec.},
month = may,
pages = {507},
numpages = {1}
}

@inproceedings{10.1145/191839.191958,
author = {Missikoff, M. and Toiati, M.},
title = {MOSAICO—a System for Conceptual Modeling and Rapid Prototyping of Object-Oriented Database Application},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191958},
doi = {10.1145/191839.191958},
abstract = {The system Mosaico [MT94] has been conceived to support the design, conceptual modeling, and rapid prototyping of data intensive applications based on Object-Oriented Databases (OODBS). The application is modeled through a graphical user interface and the produced model is encoded in TQL++, the design language on which Mosaico is based.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {508},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191958,
author = {Missikoff, M. and Toiati, M.},
title = {MOSAICO—a System for Conceptual Modeling and Rapid Prototyping of Object-Oriented Database Application},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191958},
doi = {10.1145/191843.191958},
abstract = {The system Mosaico [MT94] has been conceived to support the design, conceptual modeling, and rapid prototyping of data intensive applications based on Object-Oriented Databases (OODBS). The application is modeled through a graphical user interface and the produced model is encoded in TQL++, the design language on which Mosaico is based.},
journal = {SIGMOD Rec.},
month = may,
pages = {508},
numpages = {1}
}

@inproceedings{10.1145/191839.191963,
author = {K\"{u}hn, Eva and Tschernko, Thomas and Schwarz, Konrad},
title = {A Language Based Multidatabase System},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191963},
doi = {10.1145/191839.191963},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {509},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191963,
author = {K\"{u}hn, Eva and Tschernko, Thomas and Schwarz, Konrad},
title = {A Language Based Multidatabase System},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191963},
doi = {10.1145/191843.191963},
journal = {SIGMOD Rec.},
month = may,
pages = {509},
numpages = {1}
}

@inproceedings{10.1145/191839.191965,
author = {Grossman, R. L. and Qin, X.},
title = {Ptool: A Scalable Persistent Object Manager},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191965},
doi = {10.1145/191839.191965},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {510},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191965,
author = {Grossman, R. L. and Qin, X.},
title = {Ptool: A Scalable Persistent Object Manager},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191965},
doi = {10.1145/191843.191965},
journal = {SIGMOD Rec.},
month = may,
pages = {510},
numpages = {1}
}

@inproceedings{10.1145/191839.191967,
author = {Theodoulidis, Babis and Ait-Braham, Aziz and Andrianopoulos, George and Chaudhary, Jayant and Karvelis, George and Sou, Simon},
title = {The ORES Temporal Database Management System},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191967},
doi = {10.1145/191839.191967},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {511},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191967,
author = {Theodoulidis, Babis and Ait-Braham, Aziz and Andrianopoulos, George and Chaudhary, Jayant and Karvelis, George and Sou, Simon},
title = {The ORES Temporal Database Management System},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191967},
doi = {10.1145/191843.191967},
journal = {SIGMOD Rec.},
month = may,
pages = {511},
numpages = {1}
}

@inproceedings{10.1145/191839.191970,
author = {Sagonas, Konstantinos and Swift, Terrance and Warren, David S.},
title = {XSB as a Deductive Database},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191970},
doi = {10.1145/191839.191970},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {512},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191970,
author = {Sagonas, Konstantinos and Swift, Terrance and Warren, David S.},
title = {XSB as a Deductive Database},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191970},
doi = {10.1145/191843.191970},
journal = {SIGMOD Rec.},
month = may,
pages = {512},
numpages = {1}
}

@inproceedings{10.1145/191839.197137,
author = {Dogac, Asuman and Arpinar, Budak and Evrendilek, Cem and Ozkan, Cetin and Altintas, Ilker and Durusoy, Ilker and Altinel, Mehmet and Okay, Tansel and Saygin, Yuksel},
title = {METU Object-Oriented DBMS},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.197137},
doi = {10.1145/191839.197137},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {513},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.197137,
author = {Dogac, Asuman and Arpinar, Budak and Evrendilek, Cem and Ozkan, Cetin and Altintas, Ilker and Durusoy, Ilker and Altinel, Mehmet and Okay, Tansel and Saygin, Yuksel},
title = {METU Object-Oriented DBMS},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.197137},
doi = {10.1145/191843.197137},
journal = {SIGMOD Rec.},
month = may,
pages = {513},
numpages = {1}
}

@inproceedings{10.1145/191839.191972,
author = {Agrawal, R. and Carey, M. and Faloutsos, C. and Ghosh, S. and Houtsma, M. and Imieli\'{n}ski, T. and Iyer, B. and Mahboob, A. and Miranda, H. and Srikant, R. and Swami, A.},
title = {Quest: A Project on Database Mining},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191972},
doi = {10.1145/191839.191972},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {514},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191972,
author = {Agrawal, R. and Carey, M. and Faloutsos, C. and Ghosh, S. and Houtsma, M. and Imieli\'{n}ski, T. and Iyer, B. and Mahboob, A. and Miranda, H. and Srikant, R. and Swami, A.},
title = {Quest: A Project on Database Mining},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191972},
doi = {10.1145/191843.191972},
journal = {SIGMOD Rec.},
month = may,
pages = {514},
numpages = {1}
}

@inproceedings{10.1145/191839.191976,
author = {Catarci, Tiziana and Santucci, Giuseppe},
title = {Query by Diagram: A Graphical Environment for Querying Databases},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191976},
doi = {10.1145/191839.191976},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {515},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191976,
author = {Catarci, Tiziana and Santucci, Giuseppe},
title = {Query by Diagram: A Graphical Environment for Querying Databases},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191976},
doi = {10.1145/191843.191976},
journal = {SIGMOD Rec.},
month = may,
pages = {515},
numpages = {1}
}

@inproceedings{10.1145/191839.191979,
author = {Han, Jiawei and Fu, Yongjian and Huang, Yue and Cai, Yandong and Cercone, Nick},
title = {DBLearn: A System Prototype for Knowledge Discovery in Relational Databases},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191979},
doi = {10.1145/191839.191979},
abstract = {A prototyped data mining system, DBLearn, has been developed, which efficiently and effectively extracts different kinds of knowledge rules from relational databases. It has the following features: high level learning interfaces, tightly integrated with commercial relational database systems, automatic refinement of concept hierarchies, efficient discovery algorithms and good performance. Substantial extensions of its knowledge discovery power towards knowledge mining in object-oriented, deductive and spatial databases are under research and development.},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {516},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191979,
author = {Han, Jiawei and Fu, Yongjian and Huang, Yue and Cai, Yandong and Cercone, Nick},
title = {DBLearn: A System Prototype for Knowledge Discovery in Relational Databases},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191979},
doi = {10.1145/191843.191979},
abstract = {A prototyped data mining system, DBLearn, has been developed, which efficiently and effectively extracts different kinds of knowledge rules from relational databases. It has the following features: high level learning interfaces, tightly integrated with commercial relational database systems, automatic refinement of concept hierarchies, efficient discovery algorithms and good performance. Substantial extensions of its knowledge discovery power towards knowledge mining in object-oriented, deductive and spatial databases are under research and development.},
journal = {SIGMOD Rec.},
month = may,
pages = {516},
numpages = {1}
}

@inproceedings{10.1145/191839.191983,
author = {Biliris, Alexandros and Panagos, Euthimios},
title = {EOS: An Extensible Object Store},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191983},
doi = {10.1145/191839.191983},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {517},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191983,
author = {Biliris, Alexandros and Panagos, Euthimios},
title = {EOS: An Extensible Object Store},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191983},
doi = {10.1145/191843.191983},
journal = {SIGMOD Rec.},
month = may,
pages = {517},
numpages = {1}
}

@inproceedings{10.1145/191839.191986,
author = {Hwang, S.-Y. and Lim, E.-P. and Yang, H.-R. and Musukula, S. and Mediratta, K. and Ganesh, M. and Clements, D. and Stenoien, J. and Srivastava, J.},
title = {The MYRIAD Federated Database Prototype},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191986},
doi = {10.1145/191839.191986},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {518},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191986,
author = {Hwang, S.-Y. and Lim, E.-P. and Yang, H.-R. and Musukula, S. and Mediratta, K. and Ganesh, M. and Clements, D. and Stenoien, J. and Srivastava, J.},
title = {The MYRIAD Federated Database Prototype},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191986},
doi = {10.1145/191843.191986},
journal = {SIGMOD Rec.},
month = may,
pages = {518},
numpages = {1}
}

@inproceedings{10.1145/191839.191988,
author = {Brinkhoff, Thomas and Kriegel, Hans-Peter and Schneider, Ralf and Seeger, Bernhard},
title = {GENESYS: A System for Efficient Spatial Query Processing},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191988},
doi = {10.1145/191839.191988},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {519},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191988,
author = {Brinkhoff, Thomas and Kriegel, Hans-Peter and Schneider, Ralf and Seeger, Bernhard},
title = {GENESYS: A System for Efficient Spatial Query Processing},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191988},
doi = {10.1145/191843.191988},
journal = {SIGMOD Rec.},
month = may,
pages = {519},
numpages = {1}
}

@inproceedings{10.1145/191839.191989,
author = {Blakeley, Jos\'{e} A.},
title = {Open Object Database Management Systems},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191989},
doi = {10.1145/191839.191989},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {520},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191989,
author = {Blakeley, Jos\'{e} A.},
title = {Open Object Database Management Systems},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191989},
doi = {10.1145/191843.191989},
journal = {SIGMOD Rec.},
month = may,
pages = {520},
numpages = {1}
}

@inproceedings{10.1145/191839.191990,
author = {Mohan, C.},
title = {A Survey and Critique of Advanced Transaction Models},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191990},
doi = {10.1145/191839.191990},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {521},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191990,
author = {Mohan, C.},
title = {A Survey and Critique of Advanced Transaction Models},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191990},
doi = {10.1145/191843.191990},
journal = {SIGMOD Rec.},
month = may,
pages = {521},
numpages = {1}
}

@inproceedings{10.1145/191839.191991,
author = {Jagadish, H. V.},
title = {Databases for Networks},
year = {1994},
isbn = {0897916395},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191839.191991},
doi = {10.1145/191839.191991},
booktitle = {Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data},
pages = {522},
numpages = {1},
location = {Minneapolis, Minnesota, USA},
series = {SIGMOD '94}
}

@article{10.1145/191843.191991,
author = {Jagadish, H. V.},
title = {Databases for Networks},
year = {1994},
issue_date = {June 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0163-5808},
url = {https://doi.org/10.1145/191843.191991},
doi = {10.1145/191843.191991},
journal = {SIGMOD Rec.},
month = may,
pages = {522},
numpages = {1}
}

